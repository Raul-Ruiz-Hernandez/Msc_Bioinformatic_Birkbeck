---
title: "Seurat - 3 Donors analysis"
output:
  html_document:
    theme: united
    df_print: kable
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---

```{r setup, include=FALSE}
all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE,
  error = TRUE
)
```

`knitr` will automatically measure how long each code chunk takes to run and store these times in the `all_times` list, keyed by the chunk's label. This is very useful for profiling your analysis and identifying steps that take a long time. The global options ensure this timing (and other output suppression) happens for all chunks unless explicitly overridden for a specific chunk.

# SETUP SEURAT OBJECT

For this analysis we will be analyzing the Seurat object from file [https://ftp.ebi.ac.uk/biostudies/fire/E-MTAB-/544/E-MTAB-9544/Files/scPure2_AllIntegrated.rds](https://linkprotect.cudasvc.com/url?a=https%3a%2f%2fftp.ebi.ac.uk%2fbiostudies%2ffire%2fE-MTAB-%2f544%2fE-MTAB-9544%2fFiles%2fscPure2_AllIntegrated.rds&c=E,1,_dJNSKpjyT69Pt6Bul13igu06Vwi2h1uvzxLxkul8e33zlbwgI9RYoAQo0BRComifUub2lwDUVtan6GLMfl8Xk18hCpZNUL_n7GGqhH8rSI,&typo=1). The authors of the paper data integration protocol in Seurat to map all samples to the same UMAP projection. The integrated dataset contains a total of 12,973 cells.

P​aper: [https://doi.org/10.3389/fimmu.2021.602539](https://linkprotect.cudasvc.com/url?a=https%3a%2f%2fdoi.org%2f10.3389%2ffimmu.2021.602539&c=E,1,GfVIaslsG1U3s2cGauHDGTJV88_0rkz-1jMZcduANMTHyvR28IZTDRjal0VB5uMVrFk-IdJ08GQI8TMZMsp5E4gTn8z_Hv-RE8PTu7kzJfeoziyCEzLVyYo,&typo=1)  

Peripheral blood mononuclear cells were isolated from a male healthy volunteer aged 25 (HB6) sorted into **Transitional** (CD19+IgD+CD27-CD10+), **Naïve** (CD19+IgD+CD27-CD10-), **IgM Memory** (CD19+IgD+CD27+), **Classical Memory** (CD19+IgD-CD27+) and **Double Negative** (CD19+IgD-CD27-) populations.

Also Additional HB34 (male, 36 y.o.) and HB78 (male, 25 y.o) B cell samples were isolated using StemCell (Kit), FACS sorted in the same manner and each population tagged with Biolegend TotalSeq-C Hashtag antibodies.

### Loading the Seurat object for HB6, HB34 & HB78

Correct directory for the data:

```{r}
getwd()
```

```{r init}
library(dplyr)
library(Seurat)
library(patchwork)
library(ggplot2)
library(dplyr)
library(viridis) # For color scales in the composition plot
```

Load the file of the 3 donors: scPure2_AllIntegrated.rds into a Seurat object:

```{r}
# Define the full path to the .rds file
rds_file_path <- "./Data/scPure2_AllIntegrated.rds"

# Load the object from the .rds file
# You can name the loaded object whatever you want
Alldonors_object <- readRDS(file = rds_file_path)

# Now the object is loaded into the variable 'Alldonors_object'
```

### Checking the object:

It already filtered as in the paper?

```{r}
cat("Alldonors_object: ")
#Checking the obejct.
UpdateSeuratObject(Alldonors_object)
```

Update

```{r}
Alldonors_object <- UpdateSeuratObject(Alldonors_object)
```

Now check

```{r}
# Access the 'orig.ident' column directly from the metadata of Alldonors_object
orig_ident_values  <- Alldonors_object@meta.data$orig.ident
Population_values  <- Alldonors_object@meta.data$Population
# Get the unique values from that column
unique_orig_idents <- unique(orig_ident_values) # "HB6"  "HB34" "HB78"
unique_Populations <- unique(Population_values) # "Classical_Memory" "Naive" "IgM_Memory"  "DN" "Transitional"

# Print the unique values
cat("Unique values found in the 'orig.ident' column of Alldonors_object:\n")
print(unique_orig_idents)
print(unique_Populations)

# Display a quick summary of the new objectS
cat("Alldonors_object loaded with", ncol(Alldonors_object), "cells and", nrow(Alldonors_object), "features.\n")


```

General overview:

```{r}
print(head(Alldonors_object))
print(head(Alldonors_object@meta.data))
```

### Checking the donor HB78:

```{r}
# Access the full metadata table
full_metadata <- Alldonors_object@meta.data

# Subset the metadata for cells where orig.ident is "HB78"
hb78_specific_metadata <- subset(full_metadata, orig.ident == "HB78")
# Alternative subsetting:
# hb78_specific_metadata <- full_metadata[full_metadata$orig.ident == "HB78", ]

# The following lines will now always execute:
cat("Metadata for cells with orig.ident == 'HB78' (first few rows):\n")
print(head(hb78_specific_metadata))

cat("\nNumber of cells from 'HB78':", nrow(hb78_specific_metadata), "\n")

cat("\nAvailable metadata columns for these HB78 cells are:\n")
print(colnames(hb78_specific_metadata))
```

Yes, it is present.

### Contaminant cells ?

DO we have B cells in the AllDonors\_ object ? Some..

```{r}

cat("Initial dimensions of Alldonors_object:\n")
print(dim(Alldonors_object))
cat("Initial number of genes:", nrow(Alldonors_object), "\n")
cat("Initial number of cells:", ncol(Alldonors_object), "\n")

# --- Step 1: Filter genes detected in fewer than min_cells_threshold ---

# Get the count data from the RNA assay
counts <- GetAssayData(Alldonors_object, assay = "RNA", slot = "counts")

# Calculate the number of cells each gene is expressed in
n_cells_per_gene <- Matrix::rowSums(counts > 0) # Using Matrix::rowSums

# Identify genes to keep (expressed in >= min_cells_threshold cells)
genes_to_keep <- names(n_cells_per_gene[n_cells_per_gene >= min_cells_threshold])

cat(paste0("\nNumber of genes originally: ", nrow(counts), "\n"))
cat(paste0("Number of genes expressed in >= ", min_cells_threshold, " cells: ", length(genes_to_keep), "\n"))
cat(paste0("Number of genes to be removed: ", nrow(counts) - length(genes_to_keep), "\n"))

# Subset the Seurat object to keep only the selected genes, updating Alldonors_object
Alldonors_object <- Alldonors_object[genes_to_keep, ]

cat(paste0("\nDimensions after filtering genes expressed in < ", min_cells_threshold, " cells:\n"))
print(dim(Alldonors_object)) # Reflects updated Alldonors_object

# --- Step 2: Filter cells with fewer than min_features_threshold detected genes ---
# This script assumes 'nFeature_RNA' is present in Alldonors_object@meta.data.

cat(paste0("\nNumber of cells before filtering by nFeature_RNA: ", ncol(Alldonors_object), "\n"))

# Store number of cells before cell filtering for the message
cells_before_nFeature_filtering <- ncol(Alldonors_object)

# Subset cells: keep cells with >= min_features_threshold detected features (genes), updating Alldonors_object
Alldonors_object <- subset(Alldonors_object, subset = nFeature_RNA >= min_features_threshold)

cat(paste0("Number of cells after filtering (nFeature_RNA >= ", min_features_threshold, "): ", ncol(Alldonors_object), "\n"))
cat("Number of cells removed in this step:", cells_before_nFeature_filtering - ncol(Alldonors_object), "\n")

cat("\nFinal dimensions of Alldonors_object after all filtering:\n")
print(dim(Alldonors_object))
```

# 1. PAPER ANALYSIS (AllDonors_Object)

### represent UMAP object

Print

```{r}
# Assuming your Seurat object is named 'loaded_umap3d_object'
names(Alldonors_object@reductions)
```

Unless I update the object it would not work for Seurat v5:

```{r}
#Update the Seurat object (other it would no work):
Alldonors_object <- UpdateSeuratObject(Alldonors_object)
```

Step 2: Check the Dimensions of Your UMAP Reduction (to see is a 2D).

```{r}
if ("umap" %in% names(Alldonors_object@reductions)) {
  print(colnames(Alldonors_object@reductions$umap@cell.embeddings))
} else {
  cat("UMAP reduction not found.\n")
}
# The output [1] "UMAP_1" "UMAP_2" from your code confirms that the "umap" reduction stored in your Alldonors_object is indeed 2-dimensional.
```

You have both "pca" and "umap" reductions available. The name you need to represent the UMAP is simply **"umap"**.

You can now use the `DimPlot()` function with this name to visualize your UMAP:

```{r}
DimPlot(Alldonors_object, reduction = "umap", label = TRUE)
```

## Graphs for purity each cluster (Alldonors)

Script for Visualization:

```{r}
cat("Working with Alldonors_object:\n")
print(Alldonors_object) # Shows a summary of the object
cat("Initial dimensions of Alldonors_object:\n")
print(dim(Alldonors_object))
cat("\nUnique donor IDs in 'orig.ident':", paste(unique(Alldonors_object$orig.ident), collapse=", "), "\n")
cat("Unique values in 'Population':", paste(head(unique(Alldonors_object$Population)), collapse=", "), "...\n")
cat("Current active identities (clusters):\n")
print(table(Idents(Alldonors_object)))


```

### UMAP Plots Split by Donor (like Figure 7A from the paper):

```{r umap_by_donor}
# UMAP plot split by 'orig.ident', cells colored by active Idents (clusters)
# The 'label = TRUE' argument will label the clusters on the plot.
umap_plot_by_donor <- DimPlot(Alldonors_object, 
                              reduction = "umap", 
                              split.by = "orig.ident", # Creates separate plots for each donor
                              label = TRUE, 
                              label.size = 3, 
                              repel = TRUE) + 
                        NoLegend() # Optional: remove legend if it's too cluttered with many splits

print(umap_plot_by_donor)

# You could also try coloring by the 'Population' column:
 umap_plot_by_donor_population <- DimPlot(Alldonors_object, 
                                           reduction = "umap", 
                                           split.by = "orig.ident", 
                                           group.by = "Population", 
                                           label = FALSE) 
 print(umap_plot_by_donor_population)
```

### Purity (Ordered by purity) Alldonors clusters

Generate Cluster Composition Plots for All Donors (Hb6, HB34 and HB78; like Figure 7B of paper). Corrected Loop to Call the Function:

```{r define_composition_plot_function_simplified}

generate_donor_composition_plot <- function(
    base_seurat_object, 
    donor_id_to_plot
) {

  cat(paste0("\n--- Generating Composition Plot for Donor: ", donor_id_to_plot, " ---\n"))

  donor_subset_object <- subset(base_seurat_object, subset = orig.ident == donor_id_to_plot)

  if (ncol(donor_subset_object) == 0) {
    cat("No cells found for donor:", donor_id_to_plot, ". Skipping plot.\n")
    return(NULL)
  }

  cluster_population_counts <- table(Idents(donor_subset_object), donor_subset_object$Population)

  if (nrow(cluster_population_counts) == 0 || ncol(cluster_population_counts) == 0) {
    cat("No cluster/population data for donor:", donor_id_to_plot, ". Skipping plot.\n")
    return(NULL)
  }

  cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
  cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
  colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")

  valid_clusters_for_donor <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
  if(length(valid_clusters_for_donor) == 0){
      cat("No clusters with cells for donor:", donor_id_to_plot, ". Skipping plot.\n")
      return(NULL)
  }
  cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters_for_donor, ]
  cluster_population_df$Cluster <- factor(cluster_population_df$Cluster, levels = valid_clusters_for_donor)

  most_prevalent_population <- apply(cluster_population_counts[valid_clusters_for_donor, , drop=FALSE], 1, function(x) names(which.max(x)))
  purity_per_cluster <- sapply(valid_clusters_for_donor, function(cl) max(cluster_population_prop[cl, ], na.rm = TRUE))
  ordered_cluster_levels <- names(sort(purity_per_cluster, decreasing = TRUE, na.last = TRUE))
  
  cluster_population_df$Cluster_Ordered <- factor(cluster_population_df$Cluster, levels = ordered_cluster_levels)
  
  new_x_axis_labels_ordered <- paste0(
    ordered_cluster_levels,
    " (",
    most_prevalent_population[ordered_cluster_levels],
    ")"
  )

  cluster_population_df_for_labels <- cluster_population_df %>%
    dplyr::filter(!is.na(Cluster_Ordered) & Proportion > 0) %>%
    dplyr::arrange(Cluster_Ordered, Population_Phenotype) %>%
    dplyr::group_by(Cluster_Ordered) %>%
    dplyr::mutate(
      cumulative_proportion = cumsum(Proportion),
      label_y_position = cumulative_proportion - (Proportion / 2)
    ) %>%
    dplyr::ungroup()

  plot_title <- paste("Cluster Composition by Phenotype for Donor:", donor_id_to_plot)
  simple_subtitle <- paste("Seurat Object: Alldonors_object") # Simplified subtitle

  plot_composition <- ggplot(cluster_population_df_for_labels, aes(x = Cluster_Ordered, y = Proportion, fill = Population_Phenotype)) +
    geom_bar(stat = "identity", color = "black", linewidth = 0.3, width = 0.9) +
    scale_fill_viridis_d(option = "D") + 
    labs(
      title = plot_title,
      subtitle = simple_subtitle,
      x = "Cluster (Most Prevalent Phenotype) - Ordered by Purity",
      y = "Proportion of Cells within Cluster",
      fill = "Phenotype (Population)"
    ) +
    scale_x_discrete(labels = new_x_axis_labels_ordered) +
    theme_bw() +
    theme(
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 10, face = "italic", hjust = 0.5, margin = margin(b = 10)),
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
      # ... (rest of theme elements remain the same as before) ...
      axis.text.y = element_text(size = 10),
      axis.title.x = element_text(size = 12, margin = margin(t = 10)),
      axis.title.y = element_text(size = 12, margin = margin(r = 10)),
      legend.title = element_text(size = 11, face = "bold"),
      legend.text = element_text(size = 9),
      legend.position = "right",
      panel.grid.major.x = element_blank(),
      panel.grid.minor = element_blank(),
      plot.margin = margin(20, 20, 20, 20)
    )
  
  print(plot_composition)
  return(plot_composition)
}
```

Corrected Loop to Call the Function:

```{r}
# {r call_composition_plot_function}
# --- Generate plots for HB6, HB34 and HB78 using Alldonors_object ---
donors_to_plot <- c("HB6","HB34", "HB78")
composition_plots <- list() # To optionally store the plot objects

for (donor_id in donors_to_plot) {
  if (donor_id %in% unique(Alldonors_object$orig.ident)) {
    # Call the simplified function with only the necessary arguments
    composition_plots[[donor_id]] <- generate_donor_composition_plot(
                                        base_seurat_object = Alldonors_object,
                                        donor_id_to_plot = donor_id 
                                      )
  } else {
    # Corrected typo: $orig.ident
    cat("\nDonor ID", donor_id, "not found in Alldonors_object$orig.ident. Skipping plot for this donor.\n")
  }
}
# The closing brace for the for loop should be here if you're running it as a block
```

##### nor in purity order:

```{r}

```

### Purity (Non-Ordered) Alldonors clusters

Final:

```{r define_composition_plot_function_corrected}

library(gtools) # For mixedsort (optional, for complex cluster names)

generate_donor_composition_plot <- function(
    base_seurat_object,
    donor_id_to_plot
) {

  cat(paste0("\n--- Generating Composition Plot for Donor: ", donor_id_to_plot, " ---\n"))

  donor_subset_object <- subset(base_seurat_object, subset = orig.ident == donor_id_to_plot)

  if (ncol(donor_subset_object) == 0) {
    cat("No cells found for donor:", donor_id_to_plot, ". Skipping plot.\n")
    return(NULL)
  }

  cluster_population_counts <- table(Idents(donor_subset_object), donor_subset_object$Population)

  if (nrow(cluster_population_counts) == 0 || ncol(cluster_population_counts) == 0) {
    cat("No cluster/population data for donor:", donor_id_to_plot, ". Skipping plot.\n")
    return(NULL)
  }

  cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
  cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
  colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")

  valid_clusters_for_donor <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
  if(length(valid_clusters_for_donor) == 0){
      cat("No clusters with cells for donor:", donor_id_to_plot, "after checking counts. Skipping plot.\n")
      return(NULL)
  }
  cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters_for_donor, ]
  
  # --- 1. Order clusters on X-axis numerically/alphabetically ---
  if (requireNamespace("gtools", quietly = TRUE)) {
    sorted_cluster_ids_for_x_axis <- gtools::mixedsort(valid_clusters_for_donor)
  } else {
    if(all(!is.na(suppressWarnings(as.numeric(valid_clusters_for_donor))))){
        sorted_cluster_ids_for_x_axis <- valid_clusters_for_donor[order(as.numeric(valid_clusters_for_donor))]
    } else { 
        sorted_cluster_ids_for_x_axis <- sort(valid_clusters_for_donor)
    }
  }
  cluster_population_df$Cluster <- factor(cluster_population_df$Cluster, levels = sorted_cluster_ids_for_x_axis)

# Inside your generate_donor_composition_plot function:

  # --- 2. Order legend items (Phenotype/Population) ---
  desired_phenotype_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
  current_phenotypes_in_plot_data <- unique(cluster_population_df$Population_Phenotype)
  
  # Corrected logic for final_phenotype_levels:
  # Start with phenotypes from desired_phenotype_order that are actually in the current data
  ordered_present_phenotypes <- intersect(desired_phenotype_order, current_phenotypes_in_plot_data) # <--- CORRECTED LINE
  
  # Get any other phenotypes found in the data but not in the desired_phenotype_order
  # (or not in the 'ordered_present_phenotypes' if you prefer that logic)
  other_present_phenotypes <- setdiff(current_phenotypes_in_plot_data, ordered_present_phenotypes) 
  
  # Combine them, ensuring desired order is prioritized
  final_phenotype_levels <- c(ordered_present_phenotypes, other_present_phenotypes)
  # Ensure uniqueness in the final levels (though intersect/setdiff logic should handle this)
  final_phenotype_levels <- unique(final_phenotype_levels)

  cluster_population_df$Population_Phenotype <- factor(
    cluster_population_df$Population_Phenotype,
    levels = final_phenotype_levels
  )

  # Prepare data for y-position labels
  cluster_population_df_for_labels <- cluster_population_df %>%
    dplyr::filter(Proportion > 0) %>%
    # Arrange by Cluster (already factored) then by the new factor levels of Population_Phenotype
    # for correct stacking order in the plot that matches the legend.
    # ggplot typically stacks in the reverse order of factor levels in the legend.
    # So, if you want "Transitional" at the bottom of the stack and legend, it should be the first level.
    dplyr::arrange(Cluster, Population_Phenotype) %>% # Or desc(Population_Phenotype) - test what works for stacking
    dplyr::group_by(Cluster) %>%
    dplyr::mutate(
      cumulative_proportion = cumsum(Proportion),
      label_y_position = cumulative_proportion - (Proportion / 2)
    ) %>%
    dplyr::ungroup()

  # --- Generate the Plot ---
  plot_title <- paste("Cluster Composition by Phenotype for Donor:", donor_id_to_plot)
  simple_subtitle <- paste("Seurat Object: Alldonors_object")

  plot_composition <- ggplot(cluster_population_df_for_labels, aes(x = Cluster, y = Proportion, fill = Population_Phenotype)) +
    geom_bar(stat = "identity", color = "black", linewidth = 0.3, width = 0.9) +
    scale_fill_viridis_d(option = "D", drop = FALSE) + 
    labs(
      title = plot_title,
      subtitle = simple_subtitle,
      x = "Cluster",
      y = "Proportion of Cells within Cluster",
      fill = "Phenotype (Population)"
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 10, face = "italic", hjust = 0.5, margin = margin(b = 10)),
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      axis.title.x = element_text(size = 12, margin = margin(t = 10)),
      axis.title.y = element_text(size = 12, margin = margin(r = 10)),
      legend.title = element_text(size = 11, face = "bold"),
      legend.text = element_text(size = 9),
      legend.position = "right",
      panel.grid.major.x = element_blank(),
      panel.grid.minor = element_blank(),
      plot.margin = margin(20, 20, 20, 20)
    )
  
  print(plot_composition)
  return(plot_composition)
}
```

and then plot function

```{r call_composition_plot_function_now}

# Give your Rmd chunk a name if you like

# Ensure your Alldonors_object is loaded and ready
# Alldonors_object <- readRDS("path/to/your/Alldonors_object.rds") 
if (!exists("Alldonors_object") || !inherits(Alldonors_object, "Seurat")) {
  stop("Seurat object 'Alldonors_object' is not loaded or is not a Seurat object!")
}


donors_to_plot <- c("HB6","HB34", "HB78")
composition_plots <- list() # Optional: if you want to store the plot objects

cat("\n--- Starting plot generation loop ---\n") # Added for feedback

for (donor_id in donors_to_plot) {
  if (donor_id %in% unique(Alldonors_object$orig.ident)) {
    cat(paste0("Attempting to generate plot for donor: ", donor_id, "...\n")) # Feedback

    # This is where the function is called. This line needs to be executed.
    plot_object <- generate_donor_composition_plot(
                                    base_seurat_object = Alldonors_object,
                                    donor_id_to_plot = donor_id
                                  )

    if (!is.null(plot_object)) {
      composition_plots[[donor_id]] <- plot_object # Store the plot if you want
      cat(paste0("Plot for donor ", donor_id, " should have been displayed.\n"))
    } else {
      cat(paste0("Plot generation returned NULL for donor: ", donor_id, " (check function messages).\n"))
    }

  } else {
    cat("\nDonor ID '", donor_id, "' not found in Alldonors_object$orig.ident. Skipping plot.\n", sep="")
  }
}
cat("--- Plot generation loop finished ---\n") # Added for feedback
```

### Purity (Ordered population and purity) Alldonors clusters

Final ? here is the revised `generate_donor_composition_plot` function:

```{r define_composition_plot_function_ensure_local_vars}
# {r call_composition_plot_for_AllHB_donors_updated_ordering}

# library(gtools) # Optional for gtools::mixedsort

generate_donor_composition_plot <- function(
    base_seurat_object,
    donor_id_to_plot,
    object_name_for_subtitle = "Seurat Object"
) {

  cat(paste0("\n--- Generating Composition Plot for Donor: ", donor_id_to_plot, " from object: ", object_name_for_subtitle, " ---\n"))

  donor_subset_object <- subset(base_seurat_object, subset = orig.ident == donor_id_to_plot)

  if (ncol(donor_subset_object) == 0) {
    cat("No cells found for donor:", donor_id_to_plot, ". Skipping plot.\n")
    return(NULL)
  }

  cluster_population_counts <- table(Idents(donor_subset_object), donor_subset_object$Population)

  if (nrow(cluster_population_counts) == 0 || ncol(cluster_population_counts) == 0) {
    cat("No cluster/population data for donor:", donor_id_to_plot, ". Skipping plot.\n")
    return(NULL)
  }

  cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
  cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
  colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")

  valid_clusters_for_donor <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
  if(length(valid_clusters_for_donor) == 0){
      cat("No clusters with cells for donor:", donor_id_to_plot, ". Skipping plot.\n")
      return(NULL)
  }
  cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters_for_donor, ]
  
  # --- X-axis Ordering and Labeling ---
  most_prevalent_population <- sapply(valid_clusters_for_donor, function(cl_id) {
    if(cl_id %in% rownames(cluster_population_counts)) {
      names(which.max(cluster_population_counts[cl_id, ]))
    } else { NA }
  })
  names(most_prevalent_population) <- valid_clusters_for_donor
  
  purity_per_cluster <- sapply(valid_clusters_for_donor, function(cl_id) {
     if(cl_id %in% rownames(cluster_population_prop)) {
       max(cluster_population_prop[cl_id, ], na.rm = TRUE)
     } else { NA }
  })
  names(purity_per_cluster) <- valid_clusters_for_donor

  most_prevalent_population <- most_prevalent_population[!is.na(most_prevalent_population)]
  purity_per_cluster <- purity_per_cluster[!is.na(purity_per_cluster)]
  valid_clusters_for_donor <- intersect(names(most_prevalent_population), names(purity_per_cluster))
  if(length(valid_clusters_for_donor) == 0) { 
      cat("No valid clusters remaining for purity calculation for donor:", donor_id_to_plot, ". Skipping plot.\n")
      return(NULL)
  }

  desired_population_category_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

  cluster_sorting_df <- data.frame(
    ClusterID = valid_clusters_for_donor,
    MostPrevalentPop = most_prevalent_population[valid_clusters_for_donor],
    Purity = purity_per_cluster[valid_clusters_for_donor],
    stringsAsFactors = FALSE
  )

  present_most_prevalent_pops <- unique(cluster_sorting_df$MostPrevalentPop)
  actual_population_order_for_sorting <- intersect(desired_population_category_order, present_most_prevalent_pops)
  other_most_prevalent_pops <- setdiff(present_most_prevalent_pops, actual_population_order_for_sorting)
  final_population_order_for_sorting <- unique(c(actual_population_order_for_sorting, other_most_prevalent_pops))

  cluster_sorting_df$MostPrevalentPopFactor <- factor(
    cluster_sorting_df$MostPrevalentPop,
    levels = final_population_order_for_sorting
  )

  cluster_sorting_df_ordered <- cluster_sorting_df %>%
    dplyr::arrange(MostPrevalentPopFactor, dplyr::desc(Purity)) 

  ordered_cluster_ids_for_x_axis <- cluster_sorting_df_ordered$ClusterID

  new_x_axis_labels <- paste0(
    ordered_cluster_ids_for_x_axis,
    " (",
    cluster_sorting_df_ordered$MostPrevalentPop, 
    ")"
  )
  cluster_population_df$Cluster <- factor(cluster_population_df$Cluster, levels = ordered_cluster_ids_for_x_axis)

  # --- Legend Ordering (Phenotype/Population for fill aesthetic) ---
  # Ensure desired_phenotype_order is defined locally before use
  desired_phenotype_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN") 
  current_phenotypes_in_plot_data_detail <- unique(cluster_population_df$Population_Phenotype)
  
  ordered_present_phenotypes_detail <- intersect(desired_phenotype_order, current_phenotypes_in_plot_data_detail)
  other_present_phenotypes_detail <- setdiff(current_phenotypes_in_plot_data_detail, ordered_present_phenotypes_detail) 
  final_phenotype_levels_for_legend <- unique(c(ordered_present_phenotypes_detail, other_present_phenotypes_detail))

  cluster_population_df$Population_Phenotype <- factor(
    cluster_population_df$Population_Phenotype,
    levels = final_phenotype_levels_for_legend
  )

  cluster_population_df_for_labels <- cluster_population_df %>%
    dplyr::filter(Proportion > 0) %>%
    dplyr::arrange(Cluster, desc(Population_Phenotype)) %>% 
    dplyr::group_by(Cluster) %>%
    dplyr::mutate(
      cumulative_proportion = cumsum(Proportion),
      label_y_position = cumulative_proportion - (Proportion / 2)
    ) %>%
    dplyr::ungroup()

  plot_title <- paste("Cluster Composition by Phenotype for Donor:", donor_id_to_plot)
  current_subtitle <- paste("Source Seurat Object:", object_name_for_subtitle) 

  plot_composition <- ggplot(cluster_population_df_for_labels, aes(x = Cluster, y = Proportion, fill = Population_Phenotype)) +
    geom_bar(stat = "identity", color = "black", linewidth = 0.3, width = 0.9) +
    scale_fill_viridis_d(option = "D", drop = FALSE) + 
    labs(
      title = plot_title,
      subtitle = current_subtitle,
      x = "Cluster (Most Prevalent Phenotype) - Ordered by Population Group, then Purity",
      y = "Proportion of Cells within Cluster",
      fill = "Phenotype (Population)"
    ) +
    scale_x_discrete(labels = new_x_axis_labels) + 
    theme_bw() +
    theme(
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 10, face = "italic", hjust = 0.5, margin = margin(b = 10)),
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      axis.title.x = element_text(size = 12, margin = margin(t = 10)),
      axis.title.y = element_text(size = 12, margin = margin(r = 10)),
      legend.title = element_text(size = 11, face = "bold"),
      legend.text = element_text(size = 9),
      legend.position = "right",
      panel.grid.major.x = element_blank(),
      panel.grid.minor = element_blank(),
      plot.margin = margin(20, 20, 20, 20)
    )
  
  print(plot_composition)
  return(plot_composition)
}

## Calling the loop to print:
# {r call_composition_plot_for_Alldonors_object_donors}

# Ensure Alldonors_object is loaded and ready
# Ensure the 'generate_donor_composition_plot' function from above is defined in your session

if (!exists("Alldonors_object") || !inherits(Alldonors_object, "Seurat")) {
  stop("Seurat object 'Alldonors_object' not found or is not a Seurat object. Please ensure it is loaded.")
}
if (!"orig.ident" %in% colnames(Alldonors_object@meta.data) || !"Population" %in% colnames(Alldonors_object@meta.data) || is.null(Idents(Alldonors_object))) {
  stop("Alldonors_object is missing 'orig.ident', 'Population' metadata, or active Idents (clusters).")
}

# Define which donors you want to plot from Alldonors_object
donors_to_plot <- c("HB6", "HB34", "HB78") # Add/remove donors as needed
composition_plots_for_Alldonors <- list() # Changed list name for clarity

cat("\n--- Starting per-donor composition plot generation from Alldonors_object ---\n")

for (donor_id_val in donors_to_plot) {
  # Check against Alldonors_object's orig.ident
  if (donor_id_val %in% unique(Alldonors_object$orig.ident)) { 
    composition_plots_for_Alldonors[[donor_id_val]] <- generate_donor_composition_plot(
                                                      base_seurat_object = Alldonors_object, # Using Alldonors_object here
                                                      donor_id_to_plot = donor_id_val,
                                                      object_name_for_subtitle = "Alldonors_object" # Updated subtitle
                                                    )
  } else {
    cat("\nDonor ID '", donor_id_val, "' not found in Alldonors_object$orig.ident. Skipping plot.\n", sep="")
  }
}

cat("--- Per-donor composition plot generation from Alldonors_object finished ---\n")

# You can later access individual plots if stored, e.g.:
# print(composition_plots_for_Alldonors[["HB34"]])
```

un the loop that calls this function using your `Alldonors` object

## Entropy Score

Here

new version

```{r per_donor_entropy_scores_streamlined}

# Ensure necessary libraries are loaded
library(entropy)
library(aricode)

# --- Define Donors to Analyze ---
donors_to_analyze <- c("HB6", "HB34", "HB78")
# results_list <- list() # Optional: uncomment to store results

cat("Calculating Paper Strategy (AllDonors_object) Per-Donor Entropy and AMI Scores...\n")

# --- Loop Through Each Donor ---
for (donor_id in donors_to_analyze) {

  # 1. Subset the Seurat object for the current donor
  donor_specific_object <- subset(Alldonors_object, subset = orig.ident == donor_id)

  # Initialize scores to NA
  weighted_avg_entropy_donor <- NA
  ami_score_donor <- NA

  # Proceed only if cells are found for the donor
  if (ncol(donor_specific_object) > 0 && length(Idents(donor_specific_object)) > 0) {
    
    cluster_identities_donor <- Idents(donor_specific_object)
    original_samples_donor <- donor_specific_object$Population

    if (length(cluster_identities_donor) == length(original_samples_donor)) {
      
      # Calculate Weighted Average Entropy
      samples_split_by_cluster_donor <- split(original_samples_donor, cluster_identities_donor)
      samples_split_by_cluster_donor <- samples_split_by_cluster_donor[sapply(samples_split_by_cluster_donor, length) > 0]

      if (length(samples_split_by_cluster_donor) > 0) {
        individual_entropy_per_cluster_donor <- sapply(samples_split_by_cluster_donor, function(samples_in_cluster) {
          freq_table <- table(samples_in_cluster)
          prob_dist <- prop.table(freq_table)
          entropy::entropy(prob_dist, method = "ML", unit = "log")
        })

        clusters_present_for_entropy_donor <- names(individual_entropy_per_cluster_donor)
        cluster_counts_donor <- table(cluster_identities_donor)[clusters_present_for_entropy_donor]
        # Ensure no NAs from cluster_counts_donor indexing & all counts > 0
        valid_counts_mask <- !is.na(cluster_counts_donor) & cluster_counts_donor > 0
        cluster_counts_donor <- cluster_counts_donor[valid_counts_mask]
        individual_entropy_per_cluster_donor <- individual_entropy_per_cluster_donor[names(cluster_counts_donor)]


        if (length(individual_entropy_per_cluster_donor) > 0 && 
            length(cluster_counts_donor) == length(individual_entropy_per_cluster_donor) && 
            sum(cluster_counts_donor) > 0) {
          weighted_avg_entropy_donor <- weighted.mean(individual_entropy_per_cluster_donor, cluster_counts_donor, na.rm = TRUE)
        }
      }
      
      # Calculate Adjusted Mutual Information (AMI)
      # aricode::AMI can handle character or factor inputs
      ami_score_donor <- aricode::AMI(as.character(cluster_identities_donor), as.character(original_samples_donor))
    }
  }

  # Print results for the current donor in a single line
  cat(sprintf("Donor: %-5s | Cells: %-5d | Avg Entropy: %.4f | AMI: %.4f\n", 
              donor_id, 
              ncol(donor_specific_object), 
              weighted_avg_entropy_donor, 
              ami_score_donor))

  # Optional: Store results
  # results_list[[donor_id]] <- list(
  #   cells = ncol(donor_specific_object),
  #   weighted_entropy = weighted_avg_entropy_donor,
  #   ami = ami_score_donor
  # )
}

cat("\nPer-donor calculations complete.\n")
# If you stored results:

```

## Entropy score at 2.5 %:

```{r per_donor_entropy_scores_filtered_clusters}

# Ensure necessary libraries are loaded
library(entropy)
library(aricode)

# --- Define Donors to Analyze ---
donors_to_analyze <- c("HB6", "HB34", "HB78")
# results_list <- list() # Optional: uncomment to store results

cat("Calculating Per-Donor Entropy and AMI Scores (clusters > 2.5% of donor's cells)...\n")

# --- Loop Through Each Donor ---
for (donor_id in donors_to_analyze) {

  # 1. Subset the Seurat object for the current donor
  donor_specific_object <- subset(Alldonors_object, subset = orig.ident == donor_id)

  # Initialize scores to NA
  weighted_avg_entropy_donor <- NA
  ami_score_donor <- NA # AMI is typically calculated on all cells/clusters, but we'll filter for entropy

  total_cells_in_donor <- ncol(donor_specific_object)
  cat(sprintf("\nProcessing Donor: %-5s | Total Cells: %-5d\n", donor_id, total_cells_in_donor))

  # Proceed only if cells are found for the donor
  if (total_cells_in_donor > 0 && length(Idents(donor_specific_object)) > 0) {
    
    all_cluster_identities_donor <- Idents(donor_specific_object)
    all_original_samples_donor <- donor_specific_object$Population

    if (length(all_cluster_identities_donor) == length(all_original_samples_donor)) {
      
      # --- Filter clusters based on size (more than 2.5% of donor's total cells) ---
      min_cluster_proportion <- 0.025
      cluster_sizes <- table(all_cluster_identities_donor)
      clusters_to_keep <- names(cluster_sizes[cluster_sizes > (min_cluster_proportion * total_cells_in_donor)])
      
      if (length(clusters_to_keep) > 0) {
        cat(sprintf("  Keeping %d clusters (each > %.1f%% of donor's cells) for entropy calculation: %s\n", 
                    length(clusters_to_keep), 
                    min_cluster_proportion * 100,
                    paste(clusters_to_keep, collapse=", ")))

        # Subset data to include only cells from the selected large clusters for entropy calculation
        cells_in_large_clusters_mask <- all_cluster_identities_donor %in% clusters_to_keep
        
        cluster_identities_for_entropy <- all_cluster_identities_donor[cells_in_large_clusters_mask]
        # Ensure cluster_identities_for_entropy is a factor with only the levels of clusters_to_keep
        cluster_identities_for_entropy <- factor(cluster_identities_for_entropy, levels = clusters_to_keep)
        
        original_samples_for_entropy <- all_original_samples_donor[cells_in_large_clusters_mask]

        # Calculate Weighted Average Entropy using only the large clusters
        samples_split_by_large_cluster_donor <- split(original_samples_for_entropy, cluster_identities_for_entropy)
        # The split should not produce empty groups now if clusters_to_keep was derived from table()
        # and cells_in_large_clusters_mask correctly selected them.

        if (length(samples_split_by_large_cluster_donor) > 0) {
          individual_entropy_per_large_cluster_donor <- sapply(samples_split_by_large_cluster_donor, function(samples_in_cluster) {
            if (length(samples_in_cluster) == 0) return(NA) # Should not happen if split is correct
            freq_table <- table(samples_in_cluster)
            prob_dist <- prop.table(freq_table)
            entropy::entropy(prob_dist, method = "ML", unit = "log")
          })
          
          # Remove NAs that could result if a cluster level had no cells after all (should be filtered by cluster_sizes)
          individual_entropy_per_large_cluster_donor <- individual_entropy_per_large_cluster_donor[!is.na(individual_entropy_per_large_cluster_donor)]

          if (length(individual_entropy_per_large_cluster_donor) > 0) {
            # Get counts for the large clusters only
            cluster_counts_for_entropy <- cluster_sizes[clusters_to_keep]
            # Ensure the order matches for weighted.mean
            cluster_counts_for_entropy <- cluster_counts_for_entropy[names(individual_entropy_per_large_cluster_donor)]

            weighted_avg_entropy_donor <- weighted.mean(
              individual_entropy_per_large_cluster_donor,
              cluster_counts_for_entropy,
              na.rm = TRUE
            )
          } else {
            cat("  No valid individual entropies calculated for kept clusters.\n")
          }
        } else {
            cat("  No clusters met the size threshold for entropy calculation.\n")
        }
      } else {
        cat(sprintf("  No clusters are larger than %.1f%% of total cells for donor %s. Weighted entropy will be NA.\n", 
                    min_cluster_proportion * 100, donor_id))
      }
      
      # Calculate Adjusted Mutual Information (AMI) using ALL clusters and cells for the donor
      # AMI is a global measure of agreement between two partitionings.
      # It's generally calculated on the full set of cells for that donor.
      ami_score_donor <- aricode::AMI(as.character(all_cluster_identities_donor), as.character(all_original_samples_donor))
    } else {
        cat(sprintf("  Length mismatch between cluster IDs and population labels for donor %s. Skipping calculations.\n", donor_id))
    }
  } else {
      cat(sprintf("  No cells or Idents found for donor %s. Skipping calculations.\n", donor_id))
  }

  # Print results for the current donor in a single line
  cat(sprintf("  Donor: %-5s | Cells: %-5d | W.Avg.Entropy (clusters >2.5%%): %.4f | AMI (all clusters): %.4f\n", 
              donor_id, 
              total_cells_in_donor, # Total cells for this donor
              weighted_avg_entropy_donor, 
              ami_score_donor))

  # Optional: Store results
  # results_list[[donor_id]] <- list(
  #   cells = total_cells_in_donor,
  #   weighted_entropy_filtered_clusters = weighted_avg_entropy_donor,
  #   ami_all_clusters = ami_score_donor,
  #   kept_clusters_for_entropy = if(exists("clusters_to_keep")) clusters_to_keep else character(0)
  # )
}

cat("\nPer-donor calculations complete.\n")
# If you stored results:
# print(results_list)
```

# 2. AllHB SEURAT OBJECT

#### load Alldonors_object again and create AllHB:

```{r load all donors}
# Define the full path to the .rds file
rds_file_path <- "./Data/scPure2_AllIntegrated.rds"

# Load the object from the .rds file
# You can name the loaded object whatever you want
Alldonors_object <- readRDS(file = rds_file_path)

# Now the object is loaded into the variable 'Alldonors_object'
#Checking the obejct.
UpdateSeuratObject(Alldonors_object)

# Updating:
Alldonors_object <- UpdateSeuratObject(Alldonors_object)

# --- Start of Processing ---
# prepare new object to work with:
AllHB <- Alldonors_object
```

# [###QC parameter variables]{.underline} \@\@\@

Now parameters:

```{r setup_parameters}

# FILTERING QC1
min_cells_threshold <- 3      # Genes in < this many cells removed
min_features_threshold <- 200 # Cells with < this many features (from RNA assay) removed

# FILTERING QC2
limit_mt <- 12                # Cells with percent.mt >= this removed (keep < limit_mt)
limit_Feature_RNA <- 2500     # Cells with nFeature_RNA > this removed (upper bound for nFeature_RNA from RNA assay)
limit_ribo <- 20              # Cells with percent.ribo < this removed (keep >= limit_ribo)

# VARIATION
variables_to_regress <- c()   # Define actual variables if any, e.g., c("percent.mt", "nCount_RNA")

# SCENARIO FOR VARIABLE FEATURES (applied to 'integrated' assay's variable features)
# scenario_name <- "Scenario_1_No_IgVDJ"       ; exclude_sets_for_scenario <- c("ig_vdj")
# scenario_name <- "Scenario_2_No_Ig_Const"    ; exclude_sets_for_scenario <- c("ig_constant")
# scenario_name <- "Scenario_3_No_IgLL"        ; exclude_sets_for_scenario <- c("igll")
# scenario_name <- "Scenario_4_No_TCR"         ; exclude_sets_for_scenario <- c("tcr")
# scenario_name <- "Scenario_5_No_Removal"     ; exclude_sets_for_scenario <- c()
# scenario_name <- "Scenario_6_Remove_All_Sets"  ; exclude_sets_for_scenario <- c("ig_vdj", "ig_constant", "igll", "tcr")
scenario_name <- "Scenario_Keep_IgConstant_No_VDJ" ;exclude_sets_for_scenario <- c("ig_vdj", "igll", "tcr") # Keeps "ig_constant"
# scenario_name <- "Scenario_Keep_IgConstant_and_IgLL"; exclude_sets_for_scenario <- c("ig_vdj", "tcr")
#FILTERING
nfeat = 2000 # selection of the number of highly variable features

# CLUSTERING
dimen <- 14 # Number of PCA dimensions to use
resol <- 0.5 # Clustering resolution
# Define the specific donors you want to process for independent clustering
target_donors <- c("HB6", "HB34", "HB78") # Ensure these match your actual donor IDs

# -- Section Entropy---
  # limit population clustering population for Entropy score (%):
percentage_threshold <- 2.5

```

#### Changing Assay from Integrated to RNA:

```{r}
# --- A. Set RNA as default and Calculate QC Metrics ---
DefaultAssay(AllHB) <- "RNA"
cat("Default assay set to: RNA\n")
```

#### Metadata: Ribosomical

There is no Ribosomical data, so I need to added it. First, I need to change teh defautl assay from integrated to RNA, using the method I used for HB6.

```{r ribosomical metadata}
# Assuming your Seurat object is named 'AllHB'
# This script calculates the percentage of counts coming from ribosomal genes per cell.

# --- Calculate Percentage of Ribosomal Genes ---
cat("Calculating percentage of ribosomal genes...\n")

# Define the pattern for ribosomal genes
# "^RPS" matches genes starting with RPS (Ribosomal Protein Small subunit)
# "^RPL" matches genes starting with RPL (Ribosomal Protein Large subunit)
# Combine them with | to match either pattern
ribosomal_pattern <- "^RPS|^RPL"

# Use PercentageFeatureSet to calculate the percentage of counts for genes matching the pattern
# The [[ operator adds a new column named 'percent.ribo' to the object metadata
AllHB[["percent.ribo"]] <- PercentageFeatureSet(AllHB, pattern = ribosomal_pattern) # Change object name if necessary

cat("Percentage of ribosomal genes calculated and added as 'percent.ribo'.\n")

# --- Show QC metrics including the new column ---
cat("\nShowing metadata for the first 5 cells:\n")
print(head(AllHB@meta.data, 5))

cat("\nChecking column names in metadata:\n")
print(colnames(AllHB@meta.data))

# Note: PercentageFeatureSet will automatically find genes matching the pattern in your object.
# If the pattern doesn't match any genes in your object, the 'percent.ribo' column will
# be added, but all values will likely be 0. You can check the column names using colnames()
# and the values using head() or summary() to confirm it was added.
```

# `QC1. Filtering the raw (non-normalized data)`

DO we have B cells in the All HB Seurat Object? Some..

```{r}
exclusion_genes <- c("CD3E", "GNLY", "CD14", "FCER1A", "FCGR3A", "PPBP", "LYZ", "CD8A")
cat("--- Counts for Exclusion Genes ---\n")
#
# # Check which exclusion genes are actually present in your dataset
genes_to_show <- exclusion_genes[exclusion_genes %in% rownames(AllHB)]
#
#   # Using LayerData for Seurat v5 compatibility
exclusion_gene_counts <- LayerData(object = AllHB, assay = "RNA", layer = "counts")[genes_to_show, , drop = FALSE]
#
#  # You might also want to see a summary, e.g., total counts per gene
cat("\n--- Summary (Total Counts Per Gene) ---\n")
print(rowSums(exclusion_gene_counts))
#
# # Or how many cells express each gene (count > 0)
cat("\n--- Cells Expressing Each Gene (Count > 0) ---\n")
print(rowSums(exclusion_gene_counts > 0))
```

#### Option 1 (AllHB).

the merged `AllHB` is a Seurat object , need to be filtered to remove genes detected in fewer than X cells and cells with fewer than y detected genes. (example X=3; y=200). Now filter ( paramater introduce at the start of the script:

```{r QC 1 filtering AllHB}
# 1. Get the raw count data matrix from the 'counts' layer of the 'RNA' assay
# We need the whole counts matrix to calculate detection across all cells for each gene.
AllHB_counts_matrix <- LayerData(  object = AllHB,
  assay = "RNA",    # Specify the assay
  layer = "counts")  # Specify the layer for raw counts

# 2. Calculate the number of cells each gene is detected in (count > 0)
# rowSums(matrix > 0) efficiently counts how many columns (cells) have a value > 0 for each row (gene).
num_cells_detected_per_gene <- rowSums(AllHB_counts_matrix > 0)

# 3. Define the filtering thresholds (already introduced in experimental Parameters tested)

# 4. Identify the names of the genes that meet the min.cells threshold
# Select gene names where num_cells_detected_per_gene is >= min_cells_threshold
genes_to_keep_based_on_cells <- names(num_cells_detected_per_gene[num_cells_detected_per_gene >= min_cells_threshold])

# 5. Filter the Seurat object using subset()
# - The 'subset' argument filters cells based on the metadata column nFeature_RNA.
# - The 'features' argument filters genes using the list of gene names we just identified.

cat("Number of cells before filtering:", ncol(AllHB), "\n")
cat("Number of genes before filtering:", nrow(AllHB), "\n")

AllHB <- subset(  AllHB,
  subset = nFeature_RNA >= min_features_threshold, # Keep cells with >= min_features_threshold
  features = genes_to_keep_based_on_cells)          # Keep only the genes in this list

cat("\nNumber of cells after filtering:", ncol(AllHB), "\n")
cat("Number of genes after filtering:", nrow(AllHB), "\n")

# 'HB6.a_filtered_qc1' is your new Seurat object after applying these filters.
```

Check AllHB

```{r}
AllHB
```

##### QC Metrics AllHB

```{r qc metadata}
# --- Visualize ALL relevant QC metrics as violin plots ---
cat("Visualizing all relevant QC metrics as violin plots...\n")
VlnPlot(AllHB, features = c(
    "nFeature_RNA",      # Standard
    "nCount_RNA",        # Standard
    "percent.mt",        # Standard
    "percent.ribo",      # Calculated ribosomal percentage
), ncol = 4) # Adjusted ncol to fit more plots - might need to increase if needed


# --- FeatureScatter plots ---
# Visualize relationships between metrics
cat("\nVisualizing relationships between QC metrics using FeatureScatter...\n")

# Standard QC plots
plot1 <- FeatureScatter(AllHB, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(AllHB, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot3 <- FeatureScatter(AllHB, feature1 = "nCount_RNA", feature2 = "percent.ribo")
plot4 <- FeatureScatter(AllHB, feature1 = "percent.mt", feature2 = "percent.ribo")

# Combine and display the plots
# You can combine any of the plots using patchwork
cat("Combining and displaying FeatureScatter plots (example combination)...\n")
# Example combining some key plots
combined_scatter_plots <- plot1 + plot2 + plot3 + plot4  # Combine all  examples
print(combined_scatter_plots)
```

### FIltering Out cells by Mitocondria,Ribo and uniqueFeatures

In the example below, we visualize QC metrics, and use these to filter cells.

-   We filter cells that have unique feature counts over 2,500 or less than 200
-   We filter cells that have \>~~5~~ 12 % mitochondrial counts and equal or more than 20 % percent ribo.

```{r}
cat("Number of cells before filtering:", ncol(AllHB), "\n") # 12973 cells 

# --- Apply subsetting with multiple conditions ---
AllHB <- subset(AllHB, subset = percent.mt < limit_mt & nFeature_RNA <= limit_Feature_RNA & percent.ribo >= limit_ribo)

cat("Number of cells before filtering:", ncol(AllHB), "\n")  # 12660 cells
```

## Normalizing the data

[*Gene counts were log-normalized*]{.underline}

After removing unwanted cells from the dataset, the next step is to normalize the data. The primary goal of normalization in single-cell RNA-seq is to **account for differences in sequencing depth (or library size) between cells.** For each cell, the count of every gene (expression) is divided by the total number of unique molecular identifiers (UMIs) or read counts detected. This converts raw counts into proportions or frequencies.

We employed a [global-scaling normalization method "LogNormalize"]{.underline} that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Log-transformation reduces this mean-variance relationship and mades data more normally distributed. In Seurat v5, Normalized values are stored in `AllHB[["RNA"]]$data`, indicating the 'data' layer within the 'RNA' assay.

```{r normalize}
AllHB <- NormalizeData(AllHB, normalization.method = "LogNormalize", scale.factor = 1e4)
```

## Switch to "integrated" Assay for Downstream Analysis (Dimensionality Reduction, Clustering):

You should switch the default assay to "integrated" after you have:

-Completed all your initial QC and normalization steps on the "RNA" assay.

-Defined your scenario_name and exclude_sets_for_scenario variables (as shown in your parameter setup image).

And crucially, this switch to the "integrated" assay should happen before you:

-Apply the scenario-based filtering to select/modify the VariableFeatures() of the "integrated" assay.

-Run ScaleData() on the "integrated" assay (which will use these potentially scenario-filtered variable features).

-Proceed with PCA, UMAP, and clustering using the "integrated" assay data.

This is the recommended point to switch the default assay for the main downstream analysis if you intend to use the integrated data:

```{r}
DefaultAssay(AllHB) <- "integrated"
cat("Default assay for AllHB now set to: integrated\n")
```

Note: You should set the default assay to "integrated" *BEFORE* the following chunk(Find variable features) IF your intention is to find/re-find variable features on the "integrated" assay data.

## Variable Features (AllHB): Selection of highly variable features

We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). We and [others](https://www.nature.com/articles/nmeth.2645) have found that focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.

Our procedure in Seurat is described in detail [here](https://doi.org/10.1016/j.cell.2019.05.031), and improves on previous versions by directly modeling the mean-variance relationship inherent in single-cell data, and is implemented in the `FindVariableFeatures()` function. By default, we return **2,000 features per datase**t. These will be used in downstream analysis, like PCA.

###### Before pruning Ig and TCR related genes

```{r var_features, fig.height=5, fig.width=10}
AllHB <- FindVariableFeatures(AllHB, selection.method = 'vst', nfeatures = nfeat)

cat(paste0("Found ", length(VariableFeatures(AllHB)), " variable features in the 'integrated' assay.\n"))
# Identify the 80 most highly variable genes
top40 <- head(VariableFeatures(AllHB), 40)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(AllHB)
plot2 <- LabelPoints(plot = plot1, points = top40, repel = TRUE, max.overlaps = Inf)
plot2
```

*The following genes were removed from the list of variably expressed genes in order to prevent downstream dimensionality reduction and clustering to reflect individual/clonotype specific gene usage: all Ig V, D, J genes (extracted using the regular expression [regex] “IG[HKL][VDJ]”), Ig constant genes (IGHM, IGHD, IGHE, IGHA[1-2], IGHG[1-4], IGKC, IGLC[1-7], and AC233755.1 [which encodes IGHV4-38- 2]), IGLL genes, T-cell receptor genes (regex “TR[ABGD][CV]”).*

# FILTERING IG and TCR genes (AllHB)

Incluiding all the rest selected : *all Ig V, D, J genes (extracted using the regular expression [regex] “IG[HKL][VDJ]”), Ig constant genes (IGHM, IGHD, IGHE, IGHA[1-2], IGHG[1-4], IGKC, IGLC[1-7], and AC233755.1 [which encodes IGHV4-38- 2]), IGLL genes, T-cell receptor genes (regex “TR[ABGD][CV]”) (100+ genes were taken out of analysis). First a made a copy of the unfiltered:*

```{r}
# AllHB_original has original variable features from FindVariableFeatures()
AllHB_original <- AllHB
cat("Created AllHB_original, a copy of AllHB before custom variable feature filtering.\n")
cat("Number of variable features in AllHB_original:", length(VariableFeatures(AllHB_original)), "\n")
```

Doing the filtering according to parameters introduced at the beggining:

```{r}
cat("Initial number of variable features in AllHB:", length(VariableFeatures(AllHB)), "\n")

# --- Define Gene Sets ---

# Explicit list of Ig constant genes and other specific genes
ig_constant_genes_list <- c(
  "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
  "IGHG1", "IGHG2", "IGHG3", "IGHG4",
  "IGKC",
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
  "AC233755.1" # Specific gene mentioned (encodes IGHV4-38-2)
  
)
# Convert to a set for efficient lookup
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
# Anchored to the start (^) to avoid partial matches
ig_vdj_regex <- "^IG[HKL][VDJ]" # Ig V(D)J genes (Heavy, Kappa, Lambda)
igll_regex <- "^IGLL"          # IGLL genes
tcr_regex <- "^TR[ABGD][CV]"   # TCR V/C genes (Alpha, Beta, Gamma, Delta)


# >>>>>> SET YOUR CLUSTERING SCENARIO HERE <<<<<<


# --- Function to Filter Variable Features (Updated to show deleted genes) ---

#' Filter Variable Features by Specified Gene Sets

#' @return A character vector of filtered variable features.
#' @import Seurat # Assuming Seurat is loaded if VariableFeatures() is used
filter_variable_features_by_gene_sets <- function(
  seurat_object,
  exclude_sets = c(),
  ig_constant_genes_set,
  ig_vdj_regex,
  igll_regex,
  tcr_regex
) {

  cat("\n--- Identifying Genes for Removal ---\n")
  if (length(exclude_sets) > 0) {
    cat("Excluding sets:", paste(exclude_sets, collapse = ", "), "\n")
  } else {
    cat("No gene sets specified for exclusion.\n")
  }

  # Get the current list of variable features
  current_variable_genes <- VariableFeatures(seurat_object)
  cat("Number of variable features before filtering:", length(current_variable_genes), "\n")

  # Initialize list of genes to remove
  genes_to_remove <- character(0)

  # --- Identify genes to remove based on exclude_sets ---

  # Exclude Ig VDJ genes
  if ("ig_vdj" %in% exclude_sets) {
    vdj_matches <- grep(ig_vdj_regex, current_variable_genes, value = TRUE)
    genes_to_remove <- c(genes_to_remove, vdj_matches)
    cat("Identified", length(vdj_matches), "Ig VDJ genes for removal (matching regex:", ig_vdj_regex, ").\n")
  }

  # Exclude Ig constant genes
  if ("ig_constant" %in% exclude_sets) {
    # Find constant genes that are also in the current variable features
    constant_matches <- intersect(current_variable_genes, ig_constant_genes_set)
    genes_to_remove <- c(genes_to_remove, constant_matches)
    cat("Identified", length(constant_matches), "Ig constant/specific genes for removal (from provided list).\n")
  }

  # Exclude IGLL genes
  if ("igll" %in% exclude_sets) {
    igll_matches <- grep(igll_regex, current_variable_genes, value = TRUE)
    genes_to_remove <- c(genes_to_remove, igll_matches)
    cat("Identified", length(igll_matches), "IGLL genes for removal (matching regex:", igll_regex, ").\n")
  }

  # Exclude TCR genes
  if ("tcr" %in% exclude_sets) {
    tcr_matches <- grep(tcr_regex, current_variable_genes, value = TRUE)
    genes_to_remove <- c(genes_to_remove, tcr_matches)
    cat("Identified", length(tcr_matches), "TCR genes for removal (matching regex:", tcr_regex, ").\n")
  }

  # Ensure uniqueness in the list of genes to remove
  genes_to_remove <- unique(genes_to_remove)

  cat("\nTotal unique genes identified for removal:", length(genes_to_remove), "\n")
  
  # >>>>> ADDED SECTION TO LIST THE REMOVED GENES <<<<<
  if (length(genes_to_remove) > 0) {
    cat("List of unique genes removed from VariableFeatures:\n")
    # To avoid overly long output, print a few and then the total, or print all if not too many
    if (length(genes_to_remove) <= 50) { # Arbitrary threshold for printing all
      cat(paste(genes_to_remove, collapse = ", "), "\n")
    } else {
      cat(paste(head(genes_to_remove, 50), collapse = ", "), "...\n")
      cat("(Showing first 50 out of", length(genes_to_remove), "genes removed. Full list is in 'genes_to_remove' if captured.)\n")
    }
  }
  # >>>>> END OF ADDED SECTION <<<<<

  # --- Perform Filtering ---
  if (length(genes_to_remove) > 0) {
    # Create the new list of variable features by excluding the identified genes
    filtered_variable_genes <- setdiff(current_variable_genes, genes_to_remove)
    cat("Number of variable features after filtering:", length(filtered_variable_genes), "\n")
  } else {
    cat("No genes were specified for removal or none matched the variable features.\n")
    filtered_variable_genes <- current_variable_genes # Keep all if none to remove
    cat("Number of variable features remains:", length(filtered_variable_genes), "\n")
  }

  cat("--- Filtering Identification Complete ---\n")
  return(filtered_variable_genes)
}


cat(paste0("\n### Running Analysis Scenario: ", scenario_name, " ###\n"))

# --- 1. Filter Variable Features based on the chosen scenario ---

# Get the filtered list of variable features
# Ensure AllHB exists and is a Seurat object before this point
if (!exists("AllHB") || !inherits(AllHB, "Seurat")) {
  stop("Seurat object 'AllHB' not found or is not a Seurat object. Please load your data.")
}

filtered_vars <- filter_variable_features_by_gene_sets(
  seurat_object = AllHB, 
  exclude_sets = exclude_sets_for_scenario,
  ig_constant_genes_set = ig_constant_genes_set,
  ig_vdj_regex = ig_vdj_regex,
  igll_regex = igll_regex,
  tcr_regex = tcr_regex
)

# Update the VariableFeatures in the original object
VariableFeatures(AllHB) <- filtered_vars
cat("Variable features updated in the working object: AllHB.\n")
cat("New number of variable features:", length(VariableFeatures(AllHB)), "\n")

```

After filtering:

```{r}
# Identify the 50 most highly variable genes
top50 <- head(VariableFeatures(AllHB), 50)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(AllHB)
plot2 <- LabelPoints(plot = plot1, points = top50, repel = TRUE)
plot2
```

Which are the most 50 variable genes? Get the list of all variable features identified.:

```{r}
# This list is automatically ordered from most variable to least variable.
all_variable_genes <- VariableFeatures(AllHB)

# Select the first 50 genes from the ordered list using head()
top_50_variable_genes <- head(all_variable_genes, 50)

# Print the list of the top 200 variable genes
cat("Top", 50, "most variable genes:\n")
print(top_50_variable_genes)
```

*Note: If you have removed Ig and TCR-associated genes from the `VariableFeatures` list of your Seurat object (`AllHB`), then those specific genes will **not** be considered during the `ScaleData` step*

Next, we apply a linear transformation ('scaling') that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The `ScaleData()` function:

-   Shifts the expression of each gene, so that the mean expression across cells is 0
-   Scales the expression of each gene, so that the variance across cells is 1
    -   This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate
-   The results of this are stored in `AllHB[["RNA"]]$scale.data`
-   By default, only variable features are scaled.
-   You can specify the `features` argument to scale additional features

`{# {r regress, results='hide'} # all.genes <- rownames(AllHB) # AllHB <- ScaleData(AllHB, features = all.genes)`

ckecking All HB

```{r}
AllHB
```

### Scaling

## **Removing unwanted sources of variation through scaling (all genes)**

In Seurat, we also use the `ScaleData()` function to remove unwanted sources of variation from a single-cell dataset. For example, we could 'regress out' heterogeneity associated with (for example) [cell cycle stage](https://satijalab.org/seurat/articles/cell_cycle_vignette), or mitochondrial contamination i.e.:

Scaling all genes can be computationally intensive for large datasets.Often, you only need to scale the variable features used for PCA. But for HB6, `ScaleData()` **defaults to using the genes stored in `VariableFeatures(object).`**

```{r regress, results='hide'}
# Assuming AllHB is your Seurat object after normalization,
# variable feature identification, and calculation of the %/count metrics.

# Define the variables you want to regress out at section: Experimental Parameters Been tested

# --- Section 1: Global Scaling of Integrated Data ---
# This scales the data in the 'integrated' assay based on the filtered variable features.
# This happens ONCE on the main AllHB object before splitting.
cat("\n--- Section 1: Global Scaling of Integrated Data ---\n")
cat("Scaling data in the 'integrated' assay (using filtered variable features)...\n") 

# Run ScaleData, specifying the variables to regress
AllHB <- ScaleData(object = AllHB, vars.to.regress = variables_to_regress)
# You can also specify 'features' here if you only want to scale/regress a subset of genes (e.g., VariableFeatures(AllHB))
# Example scaling only variable features:
# features = VariableFeatures(AllHB)

cat("ScaleData complete. Variation from", paste(variables_to_regress, collapse = ", "), "has been regressed out.\n")
```

# CLUSTERING

## Perform linear dimensional reduction

Next we perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using `features` argument if you wish to choose a different subset (if you do want to use a custom subset of features, make sure you pass these to `ScaleData` first).

For the first principal components, Seurat outputs a list of genes with the most positive and negative loadings, representing modules of genes that exhibit either correlation (or anti-correlation) across single-cells in the dataset.

```{r pca,results='hide'}
# This performs PCA on the scaled integrated data, using the filtered variable features.
# This happens ONCE on the main AllHB object before splitting.
cat("\n--- Section 2: Global PCA on Integrated Data ---\n")
AllHB<- RunPCA(AllHB, features = VariableFeatures(object = AllHB), verbose = FALSE)
# AllHB <- RunPCA(AllHB, features = VariableFeatures(AllHB), npcs = 30, verbose = FALSE) # Using 30 PCs as a good starting point
```

Seurat provides several useful ways of visualizing both cells and features that define the PCA, including `VizDimReduction()`, `DimPlot()`, and `DimHeatmap()`

```{r pca_viz, fig.height=8, fig.width=10, message=TRUE}
# Examine and visualize PCA results a few different ways
#print(AllHB[['pca']], dims = 1:5, nfeatures = 5)
# VizDimLoadings(AllHB, dims = 1:2, reduction = 'pca')
# 
# # Color the PCA plot by the 'Population' metadata column
# DimPlot(AllHB, reduction = 'pca', group.by = 'Population')

# If you want to keep the legend to see which color corresponds to which Population,
# you should remove the '+ NoLegend()' part:
# DimPlot(AllHB, reduction = 'pca', group.by = 'Population')
```

## Determine the 'dimensionality' of the dataset

To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a 'metafeature' that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many components should we choose to include? 10? 20? 100?

An alternative heuristic method generates an 'Elbow plot': a ranking of principle components based on the percentage of variance explained by each one (`ElbowPlot()` function). In this example, we can observe an 'elbow' around PC9-10, suggesting that the majority of true signal is captured in the first 10 PCs.

```{r elbow_plot, fig.height=6, fig.width=10}
# ElbowPlot(AllHB) + 
#   geom_hline(yintercept = 1.5, linetype = "dashed", color = "red")
```

*Principal Component Analysis (PCA) was then performed on this pruned gene list. Surveying the first 50 principal components, the proportion of variance explained plateaued at \~ 1.5% from the 15th PC onwardsPrincipal Component Analysis (PCA) was then performed on this pruned gene list. Surveying the first 50 principal components, the proportion of variance explained plateaued at \~ 1.5% from the 15th PC onwards*

# 3. ONLY_HB6/34/78

### Global UMAP on Integrated Data (AllHB)

```{r}
# --- Section 3: Global UMAP on Integrated Data ---
# This computes the UMAP embedding based on the PCA results from the integrated data.
# This creates the common dimensional space for visualization.
# This happens ONCE on the main AllHB object before splitting.
cat("\n--- Section 3: Global UMAP on Integrated Data ---\n")
cat(paste0("Running UMAP on the 'integrated' assay using ", dimen, " dimensions...\n"))
AllHB <- RunUMAP(AllHB, reduction = "pca", dims = 1:dimen, verbose = FALSE)
cat("Global UMAP computation complete. Common dimensional space established.\n")
```

Note: *Uniform Manifold Approximation and Projection (UMAP) was performed based on the first 14 PCs, using the implementation in the python umap-learn package with correlation as the distance measure in the PC space. UMAP projections were produced on both two-dimensional and threedimensional spaces.*

### Splitting AllHB by Donor for Independent Clustering

```{r}
# --- Section 4: Splitting AllHB by Donor for Independent Clustering ---
# The AllHB object now has its 'integrated' assay fully processed (scaled, PCA, UMAP).
# When split, each donor's sub-object will inherit these reductions.
cat("\n--- Section 4: Splitting AllHB by Donor for Independent Clustering ---\n")
cat("Splitting the AllHB object by donor...\n")
split_objects_by_donor <- SplitObject(AllHB, split.by = "orig.ident")
cat("Object split by donor.\n")
```

## Finding Neighbors and Clusters for Each Donor (Independent Clustering)

T*o define cell clusters, a shared nearest neighbor (SNN) graph was constructed using Seurat:: FindNeighbors based on the first 14 PCs, and cell clusters were defined on the SNN graph with Seurat::FindClusters (resolution parameter = 1). Clusters were named according to manual inspection for their composition in terms of the original FACSdefined populations. Differential expression was examined using the Wilcoxon rank-sum test provided in Seurat::FindMarkers. Analysis for the additional samples followed the same procedure, retaining principal components that explained at least 1.5% of the variance.*

```{r clustering}
# --- Section 5: Finding Neighbors and Clusters for Each Donor (Independent Clustering) ---
# This loop processes each specified donor individually.
# It uses the inherited PCA from the 'integrated' assay for neighbor finding and clustering.
cat("\n--- Section 5: Finding Neighbors and Clusters for Each Donor (Independent Clustering) ---\n")

# Create lists to store the processed donor objects and their UMAP plots
processed_target_donor_objects <- list()
final_donor_umaps <- list()

# Loop through only the target donors
for (donor_id in target_donors) {
  # Check if the donor actually exists in your split object list
  if (!donor_id %in% names(split_objects_by_donor)) {
    cat(paste0("Warning: Donor '", donor_id, "' not found in AllHB. Skipping.\n"))
    next # Skip to the next iteration if donor not found
  }
  
  cat(paste0("\n--- Processing donor: ", donor_id, " ---\n"))
  
  # Get the donor-specific Seurat object
  donor_object <- split_objects_by_donor[[donor_id]]
  
  # The default assay is already 'integrated' for donor_object.
  # The donor_object already has its 'integrated' assay with scaled data,
  # filtered variable features, PCA reduction, and UMAP reduction inherited from global AllHB.
  
  # Find Neighbors for this specific donor (uses its inherited PCA from integrated assay)
  cat(paste0("  Finding neighbors for donor ", donor_id, " using ", dimen, " dimensions from integrated PCA...\n"))
  donor_object <- FindNeighbors(donor_object, dims = 1:dimen, verbose = FALSE)
  
  # Find Clusters for this specific donor (uses the neighbor graph just created)
  cat(paste0("  Finding clusters for donor ", donor_id, " with resolution ", resol, "...\n"))
  donor_object <- FindClusters(donor_object, resolution = resol, verbose = FALSE)
  
  cat(paste0("  Found ", length(levels(donor_object)), " independent clusters for donor ", donor_id, ".\n"))
  
  # Store the fully processed donor object (optional, but good for later access)
  processed_target_donor_objects[[donor_id]] <- donor_object
  
  # --- Visualization of Independent Clusters on Shared Integrated UMAP Space ---
  # The donor_object inherited the global 'umap' reduction.
  # We now plot it, coloring by the newly found independent 'seurat_clusters'.
  cat(paste0("  Generating UMAP plot for donor: ", donor_id, "...\n"))
  
  p <- DimPlot(donor_object,
               reduction = "umap", # Use the global UMAP reduction
               group.by = "seurat_clusters", # Color by the new, donor-specific clusters
               label = TRUE,
               label.size = 6,
               repel = TRUE) +
    NoLegend() + # Remove legend if preferred, or adjust positioning
    labs(title = paste0("Donor: ", donor_id))
  #labs(title = paste0("Donor: ", donor_id, " (Integrated Clusters, Filtered Genes)"))
  # Store the generated plot in our list
  final_donor_umaps[[donor_id]] <- p
} # END of the for loop
```

Paper: T*o define cell clusters, a shared nearest neighbor (SNN) graph was constructed using Seurat:: FindNeighbors based on the first 14 PCs, and cell clusters were defined on the SNN graph with Seurat::FindClusters (resolution parameter = 1). Clusters were named according to manual inspection for their composition in terms of the original FACSdefined populations. Differential expression was examined using the Wilcoxon rank-sum test provided in Seurat::FindMarkers. Analysis for the additional samples followed the same procedure, retaining principal components that explained at least 1.5% of the variance.*

### UMAP Split by Donor (like Figure 7A from the paper):

##### Independant clusters

```{r}
# --- Section 6: Combine and Display Final Plots ---
cat("\n--- Section 6: Combining and Displaying Final Plots ---\n")
cat("Combining plots for final visualization...\n")

# Use patchwork to arrange the plots side-by-side
final_plot_order <- target_donors # Ensures plots are in the desired order

# Combine and print the plots directly, assuming all expected plots are present
final_combined_plot <- wrap_plots(final_donor_umaps[final_plot_order], ncol = length(final_plot_order))
print(final_combined_plot)

cat("\nScript execution complete.\n")


```

##### No Independant (AllHB)

Compare with the previous

```{r umap_AllHB_split_by_donor or population}
############ donor#######
plot_umap_allhb_split <- DimPlot(AllHB, 
                                 reduction = "umap", 
                                 split.by = "orig.ident", # Creates separate plots for HB6, HB34, HB78
                                 group.by = "seurat_clusters",
                                 label = TRUE, 
                                 label.size = 5, # Adjust label size for potentially smaller panels
                                 repel = TRUE) +
                             NoLegend()

print(plot_umap_allhb_split)
############ population#######
plot_umap_allhb_split_population <- DimPlot(AllHB,
                                            reduction = "umap",
                                            split.by = "orig.ident",
                                            group.by = "Population", # Color cells by the 'Population' metadata
                                            label = FALSE) # Labels might be too crowded for many populations
print(plot_umap_allhb_split_population)
```

### Create Indepedent Seurat Object for each donor(Olny_HB6:

```{r}
#remember than in the section : Splitting AllHB by Donor for Independent Clustering :
#Donor_object is the combined Seurat object with the 3 donor-specific data:

# remember that in finding neighbour section:
#  donor_object <- split_objects_by_donor[[donor_id]] 
# processed_target_donor_objects[[donor_id]] <- donor_object
  
# You can now access the processed Seurat objects for each donor like:
Only_HB6 <- processed_target_donor_objects[["HB6"]]
Only_HB34 <- processed_target_donor_objects[["HB34"]]
Only_HB78 <- processed_target_donor_objects[["HB78"]]
```

Checking each new object:

```{r}
Only_HB6
```

```{r}
Only_HB34
```

```{r}
Only_HB78
```

## Clustering representation

### UMAP Plot (Only_HB6):

```{r umap_AllHB_clusters}
# Assuming AllHB is your Seurat object
# Rename cluster 5 to "Transitional"
# AllHB <- RenameIdents(AllHB, `5` = "Transitional", `2` = "Naive", )

# Or check the unique identities
levels(Idents(Only_HB6))

# To verify the change, you can plot the UMAP again with the new labels
DimPlot(Only_HB6, reduction = 'umap', group.by = "seurat_clusters", label = TRUE, repel = TRUE) # label.size = 4,

# You can also add labels for the original sample names if you like (though often less clear than cluster labels)
DimPlot(object = Only_HB6, reduction = "umap", group.by = "Population", label = TRUE, repel = TRUE)

# You can also add labels for the original sample names if you like (though often less clear than cluster labels)
DimPlot(object = Only_HB6, reduction = "umap", group.by = "orig.ident", label = TRUE, repel = TRUE)

# To also show the standard cluster labels alongside the original sample coloring,
# you could use the 'split.by' argument or create separate plots.
# Example: Plot UMAP colored by original identity AND split by cluster (if clustering is done)
DimPlot(object = Only_HB6, reduction = "umap", group.by = "Population", split.by = "seurat_clusters")
```

## Graph for purity each cluster (I)

### Only_HB6 (Ordered by population and purity)

Bla bla

```{r call_composition_plot_for_Only_HB6_direct}

# Ensure the 'generate_donor_composition_plot' function is defined in your session.
# This script assumes 'Only_HB6' is loaded and correctly formatted.

# --- Plotting Execution ---

# Define the single donor ID to plot.
donor_to_plot <- "HB6"
single_donor_plot <- list() # Initialize a list to store the plot

cat("\n--- Generating composition plot for the single donor in Only_HB6 object ---\n")

# Directly call the function to generate the plot
single_donor_plot[[donor_to_plot]] <- generate_donor_composition_plot(
  base_seurat_object      = Only_HB6,
  donor_id_to_plot        = donor_to_plot,
  object_name_for_subtitle  = "Only_HB6" # Set subtitle to reflect the object name
)

cat("--- Single-donor composition plot generation finished ---\n")

# To access the plot later, you can run:
# print(single_donor_plot[["HB6"]])
```

### Only_HB34

We use again teh `generate_donor_composition_plot` function, which creates the exact legend and axis order you want.

```{r call_composition_plot_for_Only_HB34_direct}

# Define the single donor ID to plot.
donor_to_plot <- "HB34"
single_donor_plot <- list() # Initialize a list to store the plot


# Directly call the function to generate the plot
single_donor_plot[[donor_to_plot]] <- generate_donor_composition_plot(
  base_seurat_object      = Only_HB34,
  donor_id_to_plot        = donor_to_plot,
  object_name_for_subtitle  = "Only_HB34" # Set subtitle to reflect the object name
)


# To access the plot later, you can run:
# print(single_donor_plot[["HB34"]])
```

### Only_HB78

We use again teh `generate_donor_composition_plot` function, which creates the exact legend and axis order you want.

```{r call_composition_plot_for_Only_HB78_direct}

# Define the single donor ID to plot.
donor_to_plot <- "HB78"
single_donor_plot <- list() # Initialize a list to store the plot


# Directly call the function to generate the plot
single_donor_plot[[donor_to_plot]] <- generate_donor_composition_plot(
  base_seurat_object      = Only_HB78,
  donor_id_to_plot        = donor_to_plot,
  object_name_for_subtitle  = "Only_HB78" # Set subtitle to reflect the object name
)


# To access the plot later, you can run:
# print(single_donor_plot[["HB34"]])
```

##### Save rds

You can save the object at this point so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators.

```{r saveobject, eval=FALSE}
# saveRDS(AllHB, file = "./AllHB.rds") # Current working directory 
```

## Entropy Score

[Interpretation:]{.underline}

**Weighted Average Entropy**: Average sample mixedness per cell across all clusters.

  - Lower values (closer to 0) indicate clusters are, on average, less mixed with respect to Population.

```{r}
# citation("entropy")
```

**AMI Score:** Agreement between clustering and Population labels (range typically 0 to 1, higher is more agreement).

  - Lower values (closer to 0) suggest the clustering is more independent of Population (often desired after batch correction).

  - Higher values (closer to 1) suggest the clustering strongly reflects Population (could be biological difference or batch effect).

These scores can help compare different clustering runs (e.g., different resolutions or batch correction approaches).

#### Overall entropy scores for Only_HB6,/34/78

```{r per_object_entropy_scores_demonstration}

# Ensure necessary libraries are loaded
library(entropy)
library(aricode)

cat("=================================================================\n")
cat("--- Starting Entropy Calculation (Direct Execution) ---\n")
cat("=================================================================\n\n")

#----------------------------------------------------#
#                    Process HB6                     #
#----------------------------------------------------#

cat("--- Processing object: Only_HB6 ---\n")

# Define the object and donor ID for this block
current_seurat_object <- Only_HB6
donor_id              <- "HB6"

# Directly perform the calculations
cluster_identities_donor <- Idents(current_seurat_object)
original_samples_donor <- current_seurat_object$Population

samples_split_by_cluster_donor <- split(original_samples_donor, cluster_identities_donor)
samples_split_by_cluster_donor <- samples_split_by_cluster_donor[sapply(samples_split_by_cluster_donor, length) > 0]

individual_entropy_per_cluster_donor <- sapply(samples_split_by_cluster_donor, function(samples_in_cluster) {
  entropy::entropy(prop.table(table(samples_in_cluster)), method = "ML", unit = "log")
})

cluster_counts_donor <- table(cluster_identities_donor)[names(individual_entropy_per_cluster_donor)]
valid_counts_mask <- !is.na(cluster_counts_donor) & cluster_counts_donor > 0
cluster_counts_donor <- cluster_counts_donor[valid_counts_mask]
individual_entropy_per_cluster_donor <- individual_entropy_per_cluster_donor[names(cluster_counts_donor)]

weighted_avg_entropy_donor <- weighted.mean(individual_entropy_per_cluster_donor, cluster_counts_donor, na.rm = TRUE)
ami_score_donor <- aricode::AMI(as.character(cluster_identities_donor), as.character(original_samples_donor))

# Print results for this specific object
cat(sprintf("Source Object: %-10s | Donor: %-5s | Cells: %-5d | Avg Entropy: %.4f | AMI: %.4f\n\n",
            "Only_HB6", donor_id, ncol(current_seurat_object), weighted_avg_entropy_donor, ami_score_donor))


#----------------------------------------------------#
#                    Process HB34                    #
#----------------------------------------------------#

cat("--- Processing object: Only_HB34 ---\n")

# Define the object and donor ID for this block
current_seurat_object <- Only_HB34
donor_id              <- "HB34"

# Directly perform the calculations
cluster_identities_donor <- Idents(current_seurat_object)
original_samples_donor <- current_seurat_object$Population

samples_split_by_cluster_donor <- split(original_samples_donor, cluster_identities_donor)
samples_split_by_cluster_donor <- samples_split_by_cluster_donor[sapply(samples_split_by_cluster_donor, length) > 0]

individual_entropy_per_cluster_donor <- sapply(samples_split_by_cluster_donor, function(samples_in_cluster) {
  entropy::entropy(prop.table(table(samples_in_cluster)), method = "ML", unit = "log")
})

cluster_counts_donor <- table(cluster_identities_donor)[names(individual_entropy_per_cluster_donor)]
valid_counts_mask <- !is.na(cluster_counts_donor) & cluster_counts_donor > 0
cluster_counts_donor <- cluster_counts_donor[valid_counts_mask]
individual_entropy_per_cluster_donor <- individual_entropy_per_cluster_donor[names(cluster_counts_donor)]

weighted_avg_entropy_donor <- weighted.mean(individual_entropy_per_cluster_donor, cluster_counts_donor, na.rm = TRUE)
ami_score_donor <- aricode::AMI(as.character(cluster_identities_donor), as.character(original_samples_donor))

# Print results for this specific object
cat(sprintf("Source Object: %-10s | Donor: %-5s | Cells: %-5d | Avg Entropy: %.4f | AMI: %.4f\n\n",
            "Only_HB34", donor_id, ncol(current_seurat_object), weighted_avg_entropy_donor, ami_score_donor))


#----------------------------------------------------#
#                    Process HB78                    #
#----------------------------------------------------#

cat("--- Processing object: Only_HB78 ---\n")

# Define the object and donor ID for this block
current_seurat_object <- Only_HB78
donor_id              <- "HB78"

# Directly perform the calculations
cluster_identities_donor <- Idents(current_seurat_object)
original_samples_donor <- current_seurat_object$Population

samples_split_by_cluster_donor <- split(original_samples_donor, cluster_identities_donor)
samples_split_by_cluster_donor <- samples_split_by_cluster_donor[sapply(samples_split_by_cluster_donor, length) > 0]

individual_entropy_per_cluster_donor <- sapply(samples_split_by_cluster_donor, function(samples_in_cluster) {
  entropy::entropy(prop.table(table(samples_in_cluster)), method = "ML", unit = "log")
})

cluster_counts_donor <- table(cluster_identities_donor)[names(individual_entropy_per_cluster_donor)]
valid_counts_mask <- !is.na(cluster_counts_donor) & cluster_counts_donor > 0
cluster_counts_donor <- cluster_counts_donor[valid_counts_mask]
individual_entropy_per_cluster_donor <- individual_entropy_per_cluster_donor[names(cluster_counts_donor)]

weighted_avg_entropy_donor <- weighted.mean(individual_entropy_per_cluster_donor, cluster_counts_donor, na.rm = TRUE)
ami_score_donor <- aricode::AMI(as.character(cluster_identities_donor), as.character(original_samples_donor))

# Print results for this specific object
cat(sprintf("Source Object: %-10s | Donor: %-5s | Cells: %-5d | Avg Entropy: %.4f | AMI: %.4f\n\n",
            "Only_HB78", donor_id, ncol(current_seurat_object), weighted_avg_entropy_donor, ami_score_donor))


cat("=================================================================\n")
cat("--- All Per-Object Calculations Complete ---\n")
cat("=================================================================\n")
```

#### Overall entropy scores (filtered)

Corrrected score of less than 2.5%:

```{r per_donor_entropy_scores_filtered_clusters}
# {r per_object_entropy_scores_filtered_clusters_direct}

# Ensure necessary libraries are loaded
library(entropy)
library(aricode)

# --- 1. Setup: Create a named list of your Seurat objects ---
seurat_object_list <- list(
  "HB6"  = Only_HB6,
  "HB34" = Only_HB34,
  "HB78" = Only_HB78
)

cat("Calculating Per-Object Entropy and AMI Scores (clusters > 2.5% of donor's cells) -- DIRECT EXECUTION\n")

# --- 2. Loop Through Each Seurat Object in the List ---
for (donor_id in names(seurat_object_list)) {

  # Get the current Seurat object from the list
  current_seurat_object <- seurat_object_list[[donor_id]]

  total_cells_in_donor <- ncol(current_seurat_object)
  cat(sprintf("\nProcessing Donor: %-5s | Total Cells: %-5d\n", donor_id, total_cells_in_donor))

  # --- Directly perform calculations, assuming data is valid ---
  
  all_cluster_identities_donor <- Idents(current_seurat_object)
  all_original_samples_donor <- current_seurat_object$Population

  # Filter clusters based on size (more than 2.5% of donor's total cells)
  min_cluster_proportion <- 0.025
  cluster_sizes <- table(all_cluster_identities_donor)
  clusters_to_keep <- names(cluster_sizes[cluster_sizes > (min_cluster_proportion * total_cells_in_donor)])
  
  cat(sprintf("  Keeping %d clusters (each > %.1f%% of donor's cells) for entropy calculation: %s\n", 
              length(clusters_to_keep), 
              min_cluster_proportion * 100,
              paste(clusters_to_keep, collapse=", ")))

  # Subset data to include only cells from the selected large clusters
  cells_in_large_clusters_mask <- all_cluster_identities_donor %in% clusters_to_keep
  cluster_identities_for_entropy <- factor(all_cluster_identities_donor[cells_in_large_clusters_mask], levels = clusters_to_keep)
  original_samples_for_entropy <- all_original_samples_donor[cells_in_large_clusters_mask]

  # Calculate Weighted Average Entropy using only the large clusters
  samples_split_by_large_cluster_donor <- split(original_samples_for_entropy, cluster_identities_for_entropy)

  individual_entropy_per_large_cluster_donor <- sapply(samples_split_by_large_cluster_donor, function(samples_in_cluster) {
    # If a cluster is empty after split (should not happen with this logic), entropy will be NA
    if (length(samples_in_cluster) == 0) return(NA)
    entropy::entropy(prop.table(table(samples_in_cluster)), method = "ML", unit = "log")
  })
  
  # Remove NAs
  individual_entropy_per_large_cluster_donor <- individual_entropy_per_large_cluster_donor[!is.na(individual_entropy_per_large_cluster_donor)]
  
  # Get counts for the large clusters only
  cluster_counts_for_entropy <- cluster_sizes[clusters_to_keep]
  # Ensure the order matches for weighted.mean
  cluster_counts_for_entropy <- cluster_counts_for_entropy[names(individual_entropy_per_large_cluster_donor)]

  # Calculate the final scores
  weighted_avg_entropy_donor <- weighted.mean(
    individual_entropy_per_large_cluster_donor,
    cluster_counts_for_entropy,
    na.rm = TRUE
  )
  
  ami_score_donor <- aricode::AMI(as.character(all_cluster_identities_donor), as.character(all_original_samples_donor))

  # Print results for the current donor in a single line
  cat(sprintf("  Result for %-5s | W.Avg.Entropy (clusters >2.5%%): %.4f | AMI (all clusters): %.4f\n", 
              donor_id, 
              weighted_avg_entropy_donor, 
              ami_score_donor))
}

cat("\nPer-donor calculations complete.\n")
```

#### Entrpy of AllHB

```{r overall entropy scores}

# --- Construct the Title String with Parameters ---
# Assumes all parameter variables are ALREADY DEFINED in your R environment.
parameter_title <- paste0(
  "Overall Entropy and AMI Scores for Clustering of AllHB\n",
  "----------------------------------------------------------\n",
  "Analysis Parameters for Input Seurat Object & Clustering:\n",
  "  Initial Filtering: Min.cells/feature = ", min_cells_threshold,
  ", Min.features/cell = ", min_features_threshold, "\n",
  "  QC Filtering: %MT < ", limit_mt,
  ", Features/cell < ", limit_Feature_RNA,
  ", %Ribo > ", limit_ribo, "\n", # Note: your script uses > for limit_ribo
  "  Regressed Variables: ", paste(variables_to_regress, collapse = ", "), "\n",
  "  Scenario: ", scenario_name, "\n",
  "  Clustering Input: PCA Dims = ", dimen, ", Resolution = ", resol, "\n",
  "----------------------------------------------------------\n")

# --- Print the Title ---
cat(parameter_title)

# --- Load necessary libraries ---
# Assuming these are loaded if specified by user.
library(entropy) # For entropy calculation
library(aricode) # For Adjusted Mutual Information

# --- Seurat object 'AllHB' and its metadata are assumed to exist and be correctly formatted. ---

cat("Calculating overall entropy scores for the clustering run on AllHB...\n")

# 1. Get the cluster assignments and original sample identities
cluster_identities <- AllHB$seurat_clusters
original_samples <- AllHB$Population

# 2. Calculate individual entropy for each cluster
samples_split_by_cluster <- split(original_samples, cluster_identities)
# This line pre-filters empty groups. If kept, the sapply below won't process empty clusters.
# If this line were also removed, and an empty cluster was passed to sapply, table() on it would be empty.
samples_split_by_cluster <- samples_split_by_cluster[sapply(samples_split_by_cluster, length) > 0]

individual_entropy_per_cluster <- sapply(samples_split_by_cluster, function(samples_in_cluster) {
  # Internal check for empty samples_in_cluster removed as per request.
  # Directly proceeding with calculation.
  freq_table <- table(samples_in_cluster)
  prob_dist <- prop.table(freq_table)
  entropy_value <- entropy::entropy(prob_dist, method = "ML", unit = "log")
  return(entropy_value)
})

# 3. Calculate the number of cells in each *non-empty* cluster
clusters_present_for_entropy <- names(individual_entropy_per_cluster)
cluster_counts <- table(factor(cluster_identities))[clusters_present_for_entropy]

# --- Calculate Weighted Average Entropy (internal conditional logic removed) ---
# Directly calculates; will error if inputs are unsuitable (e.g., empty individual_entropy_per_cluster or sum(cluster_counts) is 0/NA)
weighted_avg_entropy <- weighted.mean(individual_entropy_per_cluster, cluster_counts, na.rm = TRUE) # na.rm kept for weighted.mean
cat("\nWeighted Average Entropy (Population per cluster):\n")
print(weighted_avg_entropy)

# --- Calculate Adjusted Mutual Information (AMI) (internal conditional logic removed) ---
# Directly calculates; will error if lengths mismatch or vectors are empty.
ami_score <- aricode::AMI(cluster_identities, original_samples)
cat("\nAdjusted Mutual Information (AMI) between clusters and Population:\n")
print(ami_score)
```

# 4.AllHB_indep

## AllHB_indep: Create a Seurat Object with independant clustering all donor:

### Split the AllHB Object and Perform Independent Clustering

he main object and run `FindNeighbors` and `FindClusters` on each piece individually inside a loop. **This is the step that creates the independent clusters.**

```{r}
AllHB
```

Now you have a list (`processed_donor_objects`) where each object has its own unique clustering. To create the side-by-side plot you want, you need to merge them back together, but first, you must rename the clusters so they don't clash (e.g., `HB6_0`, `HB34_0`)

The best way to fix this and prevent it from happening again is to perform the clustering and the renaming in the **same loop**. This ensures the renaming logic is only ever applied once to the original cluster numbers (`0`, `1`, `2`...).

Here is a single, corrected script that combines Stage 2 and Stage 3. Running this code block from your `split_objects_by_donor` step will give you the correct plot with clean labels

```{r}
# {r independent_clustering_and_visualization_renamed}

# This script starts AFTER you have run SplitObject(AllHB, ...)
# It assumes 'split_objects_by_donor' is a list of Seurat objects.

# --- 1. Independent Clustering and Renaming (Combined Loop) ---

# Define the donors you want to process
target_donors <- c("HB6", "HB34", "HB78")
processed_and_renamed_objects <- list() # A temporary list to hold results

cat("\n--- Finding independent clusters and renaming them ---\n")
for (donor_id in target_donors) {
  
  cat(paste0("Processing donor: ", donor_id, "\n"))
  
  # Get the donor-specific object
  donor_object <- split_objects_by_donor[[donor_id]]
  
  # A. Find neighbors and clusters FOR THIS DONOR ONLY
  donor_object <- FindNeighbors(donor_object, dims = 1:dimen)
  donor_object <- FindClusters(donor_object, resolution = resol) # Adjust resolution as needed
  
  # B. IMMEDIATELY rename the new clusters (e.g., '0' -> 'HB6_0')
  new_cluster_ids <- paste(donor_id, Idents(donor_object), sep = "_")
  Idents(donor_object) <- new_cluster_ids
  
  # Store the fully processed and renamed object
  processed_and_renamed_objects[[donor_id]] <- donor_object
}


# --- 2. Merge for Visualization ---

cat("\n--- Merging objects for visualization ---\n")

# Merge the objects into the newly named 'AllHB_indep' object
AllHB_indep <- merge( # <- Renamed variable
  x = processed_and_renamed_objects[["HB6"]],
  y = c(processed_and_renamed_objects[["HB34"]], processed_and_renamed_objects[["HB78"]])
)

# Manually add the UMAP reduction from the original AllHB object
AllHB_indep[['umap']] <- AllHB[['umap']] # <- Renamed variable


# --- 3. Create the Final DimPlot ---

cat("--- Generating final DimPlot ---\n")

# Use the newly named object as input for the plot
plot_independent_clusters <- DimPlot(AllHB_indep, # <- Renamed variable
                                     reduction = "umap", 
                                     split.by = "orig.ident", 
                                     label = TRUE, 
                                     repel = TRUE)

print(plot_independent_clusters)
```

what is final object?:

```{r}
AllHB_indep
```

### Purity (Ordered population and purity) AllHB_indep clusters

Final ? here is the revised `generate_donor_composition_plot` function:

```{r}
# {r generate_composition_plots_for_AllHB_indep_FIXED}

# Ensure necessary libraries are loaded
library(ggplot2)
library(dplyr)

# This script assumes your 'AllHB_indep' Seurat object is loaded and ready.

# 1. Define which donors you want to plot
donors_to_plot <- c("HB6", "HB34", "HB78")

# 2. Initialize an empty list to store the final plots
composition_plots_for_indep <- list()

cat("\n--- Starting per-donor composition plot generation from AllHB_indep ---\n")

# 3. Loop through each donor and generate a plot
for (donor_id_val in donors_to_plot) {
    
    cat(paste0("\n--- Generating plot for Donor: ", donor_id_val, " from object: AllHB_indep ---\n"))

    # Subset the main object to get only the current donor's cells
    donor_subset_object <- subset(AllHB_indep, subset = orig.ident == donor_id_val)

    if (ncol(donor_subset_object) == 0) {
        cat("No cells found for donor:", donor_id_val, ". Skipping plot.\n")
        next
    }

    cluster_population_counts <- table(Idents(donor_subset_object), donor_subset_object$Population)

    if (nrow(cluster_population_counts) == 0) {
        cat("No cluster/population data for donor:", donor_id_val, ". Skipping plot.\n")
        next
    }

    # --- (Data processing for proportions and ordering is unchanged) ---
    cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
    cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
    colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")
    valid_clusters_for_donor <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
    cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters_for_donor, ]
    most_prevalent_population <- sapply(valid_clusters_for_donor, function(cl_id) { names(which.max(cluster_population_counts[cl_id, ])) })
    purity_per_cluster <- sapply(valid_clusters_for_donor, function(cl_id) { max(cluster_population_prop[cl_id, ], na.rm = TRUE) })
    desired_population_category_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
    cluster_sorting_df <- data.frame(ClusterID = valid_clusters_for_donor, MostPrevalentPop = most_prevalent_population[valid_clusters_for_donor], Purity = purity_per_cluster[valid_clusters_for_donor])
    present_most_prevalent_pops <- unique(cluster_sorting_df$MostPrevalentPop)
    actual_population_order_for_sorting <- intersect(desired_population_category_order, present_most_prevalent_pops)
    other_most_prevalent_pops <- setdiff(present_most_prevalent_pops, actual_population_order_for_sorting)
    final_population_order_for_sorting <- unique(c(actual_population_order_for_sorting, other_most_prevalent_pops))
    cluster_sorting_df$MostPrevalentPopFactor <- factor(cluster_sorting_df$MostPrevalentPop, levels = final_population_order_for_sorting)
    cluster_sorting_df_ordered <- cluster_sorting_df %>% dplyr::arrange(MostPrevalentPopFactor, dplyr::desc(Purity))

    # --- X-axis Label Correction ---
    
    # Get the full, ordered cluster names (e.g., "HB6_2_DN")
    ordered_cluster_ids_for_x_axis <- cluster_sorting_df_ordered$ClusterID
    
    # *** THIS IS THE NEW LINE THAT FIXES THE PROBLEM ***
    # It removes the population suffix (e.g., "_DN") from the cluster name
    shortened_cluster_names <- sub("_[^_]+$", "", ordered_cluster_ids_for_x_axis)

    # Create the new, non-redundant labels
    new_x_axis_labels <- paste0(
      shortened_cluster_names, # Use the shortened names (e.g., "HB6_2")
      " (", cluster_sorting_df_ordered$MostPrevalentPop, ")" # Add the population in parentheses
    )
    
    cluster_population_df$Cluster <- factor(cluster_population_df$Cluster, levels = ordered_cluster_ids_for_x_axis)

    # --- (Legend Ordering and Plotting Code is unchanged) ---
    desired_phenotype_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
    current_phenotypes <- unique(cluster_population_df$Population_Phenotype)
    final_phenotype_levels <- intersect(desired_phenotype_order, current_phenotypes)
    final_phenotype_levels <- unique(c(final_phenotype_levels, setdiff(current_phenotypes, final_phenotype_levels)))
    cluster_population_df$Population_Phenotype <- factor(cluster_population_df$Population_Phenotype, levels = final_phenotype_levels)
    plot_composition <- ggplot(cluster_population_df, aes(x = Cluster, y = Proportion, fill = Population_Phenotype)) +
        geom_bar(stat = "identity", color = "black", linewidth = 0.3, width = 0.9) +
        scale_fill_viridis_d(option = "D", drop = FALSE) +
        labs(
            title = paste("Cluster Composition by Phenotype for Donor:", donor_id_val),
            subtitle = "Source Seurat Object: AllHB_indep",
            x = "Cluster (Most Prevalent Phenotype) - Ordered by Population Group, then Purity",
            y = "Proportion of Cells within Cluster",
            fill = "Phenotype (Population)"
        ) +
        scale_x_discrete(labels = new_x_axis_labels) +
        theme_bw() +
        theme(
            plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
            plot.subtitle = element_text(size = 10, face = "italic", hjust = 0.5, margin = margin(b = 10)),
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            axis.text.y = element_text(size = 10),
            axis.title.x = element_text(size = 12, margin = margin(t = 10)),
            axis.title.y = element_text(size = 12, margin = margin(r = 10)),
            legend.position = "right"
        )
    
    print(plot_composition)
    
    composition_plots_for_indep[[donor_id_val]] <- plot_composition
}

cat("\n--- Per-donor composition plot generation from AllHB_indep finished ---\n")
```

better:

```{r}
# {r generate_composition_plots_for_AllHB_indep_with_caption}

# Ensure necessary libraries are loaded
library(ggplot2)
library(dplyr)

# This script assumes your 'AllHB_indep' Seurat object is loaded and ready.
# It also assumes that all necessary parameter variables (e.g., 'min_cells_threshold', 'resol')
# are already defined in your R environment.

# --- 1. Construct Plot Caption from Existing Parameters ---
# This creates the multi-line caption string that will be added to each plot.
parameter_caption <- paste0(
  "Analysis Parameters (Source: AllHB):\n",
  "Initial Filtering: Min.cells/feature = ", min_cells_threshold,
  ", Min.features/cell = ", min_features_threshold, "\n",
  "QC Filtering: %MT < ", limit_mt,
  ", Features/cell <= ", limit_Feature_RNA,
  ", %Ribo >= ", limit_ribo, "\n",
  "Regressed Variables: ", paste(variables_to_regress, collapse = ", "), "\n",
  "Scenario: ", scenario_name, "\n",
  "Clustering: PCA Dims = ", dimen, ", Resolution = ", resol
)

# --- 2. Plotting Execution ---

# Define which donors you want to plot
donors_to_plot <- c("HB6", "HB34", "HB78")

# Initialize an empty list to store the final plots
composition_plots_for_indep <- list()

cat("\n--- Starting per-donor composition plot generation from AllHB_indep ---\n")

# Loop through each donor and generate a plot
for (donor_id_val in donors_to_plot) {
    
    cat(paste0("\n--- Generating plot for Donor: ", donor_id_val, " from object: AllHB_indep ---\n"))

    donor_subset_object <- subset(AllHB_indep, subset = orig.ident == donor_id_val)

    if (ncol(donor_subset_object) == 0) {
        cat("No cells found for donor:", donor_id_val, ". Skipping plot.\n")
        next
    }

    cluster_population_counts <- table(Idents(donor_subset_object), donor_subset_object$Population)

    if (nrow(cluster_population_counts) == 0) {
        cat("No cluster/population data for donor:", donor_id_val, ". Skipping plot.\n")
        next
    }

    # ... (Data processing logic for proportions and ordering is unchanged) ...
    cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
    cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
    colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")
    valid_clusters_for_donor <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
    cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters_for_donor, ]
    most_prevalent_population <- sapply(valid_clusters_for_donor, function(cl_id) { names(which.max(cluster_population_counts[cl_id, ])) })
    purity_per_cluster <- sapply(valid_clusters_for_donor, function(cl_id) { max(cluster_population_prop[cl_id, ], na.rm = TRUE) })
    desired_population_category_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
    cluster_sorting_df <- data.frame(ClusterID = valid_clusters_for_donor, MostPrevalentPop = most_prevalent_population[valid_clusters_for_donor], Purity = purity_per_cluster[valid_clusters_for_donor])
    present_most_prevalent_pops <- unique(cluster_sorting_df$MostPrevalentPop)
    actual_population_order_for_sorting <- intersect(desired_population_category_order, present_most_prevalent_pops)
    other_most_prevalent_pops <- setdiff(present_most_prevalent_pops, actual_population_order_for_sorting)
    final_population_order_for_sorting <- unique(c(actual_population_order_for_sorting, other_most_prevalent_pops))
    cluster_sorting_df$MostPrevalentPopFactor <- factor(cluster_sorting_df$MostPrevalentPop, levels = final_population_order_for_sorting)
    cluster_sorting_df_ordered <- cluster_sorting_df %>% dplyr::arrange(MostPrevalentPopFactor, dplyr::desc(Purity))
    ordered_cluster_ids_for_x_axis <- cluster_sorting_df_ordered$ClusterID
    new_x_axis_labels <- paste0(ordered_cluster_ids_for_x_axis, " (", cluster_sorting_df_ordered$MostPrevalentPop, ")")
    cluster_population_df$Cluster <- factor(cluster_population_df$Cluster, levels = ordered_cluster_ids_for_x_axis)
    desired_phenotype_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
    current_phenotypes <- unique(cluster_population_df$Population_Phenotype)
    final_phenotype_levels <- intersect(desired_phenotype_order, current_phenotypes)
    final_phenotype_levels <- unique(c(final_phenotype_levels, setdiff(current_phenotypes, final_phenotype_levels)))
    cluster_population_df$Population_Phenotype <- factor(cluster_population_df$Population_Phenotype, levels = final_phenotype_levels)

    # --- ggplot2 Plotting Code ---
    plot_composition <- ggplot(cluster_population_df, aes(x = Cluster, y = Proportion, fill = Population_Phenotype)) +
        geom_bar(stat = "identity", color = "black", linewidth = 0.3, width = 0.9) +
        scale_fill_viridis_d(option = "D", drop = FALSE) +
        labs(
            title = paste("Cluster Composition by Phenotype for Donor:", donor_id_val),
            subtitle = "Source Seurat Object: AllHB_indep",
            x = "Cluster (Most Prevalent Phenotype) - Ordered by Population Group, then Purity",
            y = "Proportion of Cells within Cluster",
            fill = "Phenotype (Population)",
            caption = parameter_caption
        ) +
        scale_x_discrete(labels = new_x_axis_labels) +
        theme_bw() +
        theme(
            plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
            plot.subtitle = element_text(size = 10, face = "italic", hjust = 0.5, margin = margin(b = 10)),
            plot.caption = element_text(size = 8, hjust = 0, face = "italic"),
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            axis.text.y = element_text(size = 10),
            axis.title.x = element_text(size = 12, margin = margin(t = 10)),
            axis.title.y = element_text(size = 12, margin = margin(r = 10)),
            legend.position = "right"
        )
    
    print(plot_composition)
    
    composition_plots_for_indep[[donor_id_val]] <- plot_composition
}

cat("\n--- Per-donor composition plot generation from AllHB_indep finished ---\n")
```

### ordered by subsets

by subset:

```{r}
# {r generate_composition_plots_for_AllHB_indep_FIXED_SPLIT}

# Ensure necessary libraries are loaded
library(ggplot2)
library(dplyr)

# This script assumes your 'AllHB_indep' Seurat object is loaded and ready.

# 1. Define which donors you want to plot
donors_to_plot <- c("HB6", "HB34", "HB78")

# 2. Initialize an empty list to store the final plots
composition_plots_for_indep <- list()

cat("\n--- Starting per-donor faceted composition plot generation from AllHB_indep ---\n")

# 3. Loop through each donor and generate a plot
for (donor_id_val in donors_to_plot) {
    
    cat(paste0("\n--- Generating plot for Donor: ", donor_id_val, " from object: AllHB_indep ---\n"))

    # Subset the main object to get only the current donor's cells
    donor_subset_object <- subset(AllHB_indep, subset = orig.ident == donor_id_val)

    if (ncol(donor_subset_object) == 0) {
        cat("No cells found for donor:", donor_id_val, ". Skipping plot.\n")
        next
    }

    cluster_population_counts <- table(Idents(donor_subset_object), donor_subset_object$Population)

    if (nrow(cluster_population_counts) == 0) {
        cat("No cluster/population data for donor:", donor_id_val, ". Skipping plot.\n")
        next
    }

    # --- (Data processing for proportions and ordering is unchanged) ---
    cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
    cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
    colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")
    valid_clusters_for_donor <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
    cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters_for_donor, ]
    most_prevalent_population <- sapply(valid_clusters_for_donor, function(cl_id) { names(which.max(cluster_population_counts[cl_id, ])) })
    purity_per_cluster <- sapply(valid_clusters_for_donor, function(cl_id) { max(cluster_population_prop[cl_id, ], na.rm = TRUE) })
    
    # --- *** MODIFICATION START *** ---
    # The subpopulations you want to split by. This is used for ordering the facets.
    desired_population_category_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
    # --- *** MODIFICATION END *** ---
    
    cluster_sorting_df <- data.frame(ClusterID = valid_clusters_for_donor, MostPrevalentPop = most_prevalent_population[valid_clusters_for_donor], Purity = purity_per_cluster[valid_clusters_for_donor])
    present_most_prevalent_pops <- unique(cluster_sorting_df$MostPrevalentPop)
    actual_population_order_for_sorting <- intersect(desired_population_category_order, present_most_prevalent_pops)
    other_most_prevalent_pops <- setdiff(present_most_prevalent_pops, actual_population_order_for_sorting)
    final_population_order_for_sorting <- unique(c(actual_population_order_for_sorting, other_most_prevalent_pops))
    cluster_sorting_df$MostPrevalentPopFactor <- factor(cluster_sorting_df$MostPrevalentPop, levels = final_population_order_for_sorting)
    cluster_sorting_df_ordered <- cluster_sorting_df %>% dplyr::arrange(MostPrevalentPopFactor, dplyr::desc(Purity))

    # --- *** MODIFICATION START: Prepare data for faceting and simplified labels *** ---

    # Get the full, ordered cluster names for setting the x-axis order
    ordered_cluster_ids_for_x_axis <- cluster_sorting_df_ordered$ClusterID
    
    # Create simplified labels for the x-axis (e.g., "HB6_2" instead of "HB6_2_DN")
    # We create a named vector to map the full ID to the simplified label.
    simplified_x_axis_labels <- sub("_[^_]+$", "", ordered_cluster_ids_for_x_axis)
    names(simplified_x_axis_labels) <- ordered_cluster_ids_for_x_axis

    # Add the faceting variable ('MostPrevalentPopFactor') to the main plotting dataframe.
    # This is essential for facet_wrap to work.
    cluster_population_df <- cluster_population_df %>%
      left_join(select(cluster_sorting_df, ClusterID, MostPrevalentPopFactor), by = c("Cluster" = "ClusterID"))

    # --- *** MODIFICATION END *** ---

    # Set the factor levels for the clusters to ensure they are plotted in the desired order
    cluster_population_df$Cluster <- factor(cluster_population_df$Cluster, levels = ordered_cluster_ids_for_x_axis)

    # --- (Legend Ordering is unchanged) ---
    desired_phenotype_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
    current_phenotypes <- unique(cluster_population_df$Population_Phenotype)
    final_phenotype_levels <- intersect(desired_phenotype_order, current_phenotypes)
    final_phenotype_levels <- unique(c(final_phenotype_levels, setdiff(current_phenotypes, final_phenotype_levels)))
    cluster_population_df$Population_Phenotype <- factor(cluster_population_df$Population_Phenotype, levels = final_phenotype_levels)
    
    # --- *** MODIFICATION START: Updated ggplot call with faceting *** ---
    
    plot_composition <- ggplot(cluster_population_df, aes(x = Cluster, y = Proportion, fill = Population_Phenotype)) +
        geom_bar(stat = "identity", color = "black", linewidth = 0.3, width = 0.9) +
        
        # Add the faceting layer to split the plot by the most prevalent population
        # `scales = "free_x"` ensures each panel only shows its own clusters
        facet_wrap(~ MostPrevalentPopFactor, scales = "free_x", ncol = 3) +
        
        scale_fill_viridis_d(option = "D", drop = FALSE) +
        labs(
            title = paste("Faceted Cluster Composition by Phenotype for Donor:", donor_id_val),
            subtitle = "Source Seurat Object: AllHB_indep. Panels group clusters by their most prevalent phenotype.",
            # Updated X-axis title
            x = "Cluster (Ordered by Purity within each Panel)",
            y = "Proportion of Cells within Cluster",
            fill = "Phenotype (Population)"
        ) +
        # Use the new, simplified labels
        scale_x_discrete(labels = simplified_x_axis_labels) +
        theme_bw() +
        theme(
            plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
            plot.subtitle = element_text(size = 10, face = "italic", hjust = 0.5, margin = margin(b = 15)),
            axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 10), # Angle changed to 90 for better fit
            axis.text.y = element_text(size = 10),
            axis.title.x = element_text(size = 12, margin = margin(t = 10)),
            axis.title.y = element_text(size = 12, margin = margin(r = 10)),
            legend.position = "right",
            # Add styling for the facet panel titles
            strip.background = element_rect(fill = "grey85", color = "black"),
            strip.text = element_text(size = 11, face = "bold")
        )

    # --- *** MODIFICATION END *** ---
        
    print(plot_composition)
    
    composition_plots_for_indep[[donor_id_val]] <- plot_composition
}

cat("\n--- Per-donor faceted composition plot generation from AllHB_indep finished ---\n")
```

```{r}
# {r generate_composition_plots_by_Subpopulation_FIXED}

# Ensure necessary libraries are loaded
library(ggplot2)
library(dplyr)

# This script assumes your 'AllHB_indep' Seurat object is loaded and ready.

# --- *** MODIFICATION: Define donors and create a single aggregated subset *** ---
# 1. Define which donors you want to aggregate and plot
donors_to_plot <- c("HB6", "HB34", "HB78")

cat(paste("\n--- Aggregating donors:", paste(donors_to_plot, collapse=", "), "from AllHB_indep ---\n"))

# 2. Subset the main object to get a single object with all specified donors' cells
all_donors_subset_object <- subset(AllHB_indep, subset = orig.ident %in% donors_to_plot)

# --- *** Data processing is now done ONCE on the aggregated data *** ---

if (ncol(all_donors_subset_object) == 0) {
    stop("No cells found for any of the specified donors. Halting script.")
}

cluster_population_counts <- table(Idents(all_donors_subset_object), all_donors_subset_object$Population)

if (nrow(cluster_population_counts) == 0) {
    stop("No cluster/population data found in the aggregated object. Halting script.")
}

# --- (Data processing for proportions and ordering is largely unchanged) ---
cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")
valid_clusters <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters, ]
most_prevalent_population <- sapply(valid_clusters, function(cl_id) { names(which.max(cluster_population_counts[cl_id, ])) })
purity_per_cluster <- sapply(valid_clusters, function(cl_id) { max(cluster_population_prop[cl_id, ], na.rm = TRUE) })
desired_population_category_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
cluster_sorting_df <- data.frame(ClusterID = valid_clusters, MostPrevalentPop = most_prevalent_population[valid_clusters], Purity = purity_per_cluster[valid_clusters])
present_most_prevalent_pops <- unique(cluster_sorting_df$MostPrevalentPop)
actual_population_order_for_sorting <- intersect(desired_population_category_order, present_most_prevalent_pops)
other_most_prevalent_pops <- setdiff(present_most_prevalent_pops, actual_population_order_for_sorting)
final_population_order_for_sorting <- unique(c(actual_population_order_for_sorting, other_most_prevalent_pops))

# The full data frame is sorted to determine global cluster order
cluster_sorting_df$MostPrevalentPopFactor <- factor(cluster_sorting_df$MostPrevalentPop, levels = final_population_order_for_sorting)
cluster_sorting_df_ordered <- cluster_sorting_df %>% dplyr::arrange(MostPrevalentPopFactor, dplyr::desc(Purity))

# Set factor levels for the legend fill
desired_phenotype_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
current_phenotypes <- unique(cluster_population_df$Population_Phenotype)
final_phenotype_levels <- intersect(desired_phenotype_order, current_phenotypes)
final_phenotype_levels <- unique(c(final_phenotype_levels, setdiff(current_phenotypes, final_phenotype_levels)))
cluster_population_df$Population_Phenotype <- factor(cluster_population_df$Population_Phenotype, levels = final_phenotype_levels)

# --- *** MODIFICATION: Loop through each SUBPOPULATION to generate separate plots *** ---

composition_plots_by_subpopulation <- list()

cat("\n--- Starting per-subpopulation plot generation (all donors aggregated) ---\n")

for (subpop_val in final_population_order_for_sorting) {
    
    cat(paste0("\n--- Generating plot for Subpopulation: ", subpop_val, " ---\n"))

    # Filter the sorting dataframe to get only clusters dominated by the current subpopulation
    clusters_for_this_plot_df <- cluster_sorting_df_ordered %>%
        filter(MostPrevalentPop == subpop_val)

    # Get the ordered list of cluster IDs for the x-axis of this specific plot
    ordered_cluster_ids_for_plot <- clusters_for_this_plot_df$ClusterID
    
    if (length(ordered_cluster_ids_for_plot) == 0) {
        cat("No clusters found for subpopulation:", subpop_val, ". Skipping plot.\n")
        next
    }

    # Filter the main plotting dataframe to include only the relevant clusters
    plot_df_subset <- cluster_population_df %>%
        filter(Cluster %in% ordered_cluster_ids_for_plot)

    # Set the cluster factor levels to ensure correct ordering on the x-axis
    plot_df_subset$Cluster <- factor(plot_df_subset$Cluster, levels = ordered_cluster_ids_for_plot)

    # Create simplified x-axis labels (e.g., "HB6_2") from the full cluster ID
    simplified_x_axis_labels <- sub("_[^_]+$", "", ordered_cluster_ids_for_plot)
    names(simplified_x_axis_labels) <- ordered_cluster_ids_for_plot

    # Generate the plot for the current subpopulation
    plot_composition <- ggplot(plot_df_subset, aes(x = Cluster, y = Proportion, fill = Population_Phenotype)) +
        geom_bar(stat = "identity", color = "black", linewidth = 0.3, width = 0.9) +
        scale_fill_viridis_d(option = "D", drop = FALSE) +
        labs(
            title = paste("Cluster Composition for", subpop_val, "Dominant Clusters"),
            subtitle = paste("Data aggregated from donors:", paste(donors_to_plot, collapse = ", ")),
            x = "Cluster (from all donors, ordered by purity)",
            y = "Proportion of Cells within Cluster",
            fill = "Phenotype (Population)"
        ) +
        scale_x_discrete(labels = simplified_x_axis_labels) +
        theme_bw() +
        theme(
            plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
            plot.subtitle = element_text(size = 10, face = "italic", hjust = 0.5, margin = margin(b = 10)),
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            axis.text.y = element_text(size = 10),
            axis.title.x = element_text(size = 12, margin = margin(t = 10)),
            axis.title.y = element_text(size = 12, margin = margin(r = 10)),
            legend.position = "right"
        )
    
    print(plot_composition)
    
    composition_plots_by_subpopulation[[subpop_val]] <- plot_composition
}

cat("\n--- Per-subpopulation plot generation finished ---\n")
```

```{r}
# {r generate_poster_figure}

# --- 1. Load Necessary Libraries ---
# Make sure you have patchwork installed: install.packages("patchwork")
library(ggplot2)
library(dplyr)
library(patchwork) # For assembling the final figure

# This script assumes your 'AllHB_indep' Seurat object is loaded and ready.

# --- 2. Define Donors and Aggregate Data ---
donors_to_plot <- c("HB6", "HB34", "HB78")
all_donors_subset_object <- subset(AllHB_indep, subset = orig.ident %in% donors_to_plot)

# --- 3. Perform Data Processing (unchanged from previous script) ---
cluster_population_counts <- table(Idents(all_donors_subset_object), all_donors_subset_object$Population)
cluster_population_prop <- prop.table(cluster_population_counts, margin = 1)
cluster_population_df <- as.data.frame(cluster_population_prop, stringsAsFactors = FALSE)
colnames(cluster_population_df) <- c("Cluster", "Population_Phenotype", "Proportion")
valid_clusters <- rownames(cluster_population_counts)[rowSums(cluster_population_counts) > 0]
cluster_population_df <- cluster_population_df[cluster_population_df$Cluster %in% valid_clusters, ]
most_prevalent_population <- sapply(valid_clusters, function(cl_id) { names(which.max(cluster_population_counts[cl_id, ])) })
purity_per_cluster <- sapply(valid_clusters, function(cl_id) { max(cluster_population_prop[cl_id, ], na.rm = TRUE) })
desired_population_category_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
cluster_sorting_df <- data.frame(ClusterID = valid_clusters, MostPrevalentPop = most_prevalent_population[valid_clusters], Purity = purity_per_cluster[valid_clusters])
present_most_prevalent_pops <- unique(cluster_sorting_df$MostPrevalentPop)
actual_population_order_for_sorting <- intersect(desired_population_category_order, present_most_prevalent_pops)
other_most_prevalent_pops <- setdiff(present_most_prevalent_pops, actual_population_order_for_sorting)
final_population_order_for_sorting <- unique(c(actual_population_order_for_sorting, other_most_prevalent_pops))
cluster_sorting_df$MostPrevalentPopFactor <- factor(cluster_sorting_df$MostPrevalentPop, levels = final_population_order_for_sorting)
cluster_sorting_df_ordered <- cluster_sorting_df %>% dplyr::arrange(MostPrevalentPopFactor, dplyr::desc(Purity))
desired_phenotype_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
current_phenotypes <- unique(cluster_population_df$Population_Phenotype)
final_phenotype_levels <- intersect(desired_phenotype_order, current_phenotypes)
final_phenotype_levels <- unique(c(final_phenotype_levels, setdiff(current_phenotypes, final_phenotype_levels)))
cluster_population_df$Population_Phenotype <- factor(cluster_population_df$Population_Phenotype, levels = final_phenotype_levels)

# --- 4. Generate and Store Individual Plots with a Poster-Ready Theme ---

# Initialize a list to store the plots
composition_plots_by_subpopulation <- list()

cat("\n--- Starting generation of poster-ready plots ---\n")

for (subpop_val in final_population_order_for_sorting) {
    
    cat(paste0("Generating plot for: ", subpop_val, "\n"))

    clusters_for_this_plot_df <- cluster_sorting_df_ordered %>% filter(MostPrevalentPop == subpop_val)
    ordered_cluster_ids_for_plot <- clusters_for_this_plot_df$ClusterID
    
    if (length(ordered_cluster_ids_for_plot) == 0) next

    plot_df_subset <- cluster_population_df %>% filter(Cluster %in% ordered_cluster_ids_for_plot)
    plot_df_subset$Cluster <- factor(plot_df_subset$Cluster, levels = ordered_cluster_ids_for_plot)
    simplified_x_axis_labels <- sub("_[^_]+$", "", ordered_cluster_ids_for_plot)
    names(simplified_x_axis_labels) <- ordered_cluster_ids_for_plot

    # Generate the plot
    p <- ggplot(plot_df_subset, aes(x = Cluster, y = Proportion, fill = Population_Phenotype)) +
        geom_bar(stat = "identity", color = "black", linewidth = 0.5, width = 0.85) + # Thicker lines
        scale_fill_viridis_d(option = "D", drop = FALSE) +
        labs(
            # A concise title for each panel
            title = subpop_val,
            x = NULL, # X-axis label removed for a cleaner look in the final grid
            y = "Proportion",
            fill = "Phenotype"
        ) +
        scale_x_discrete(labels = simplified_x_axis_labels) +
        scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) + # Standardized Y-axis
        
        # *** A dedicated theme for poster readability ***
        theme_bw(base_size = 16) + # Increase base font size
        theme(
            plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
            axis.text.y = element_text(size = 14, face = "bold"),
            axis.title.y = element_text(size = 16, face = "bold"),
            legend.title = element_text(size = 14, face = "bold"),
            legend.text = element_text(size = 12),
            legend.position = "bottom", # We will collect this later
            panel.grid.major = element_line(color = "grey80"),
            panel.grid.minor = element_blank()
        )
    
    # Store the plot in the list
    composition_plots_by_subpopulation[[subpop_val]] <- p
}

# --- 5. Assemble the Final Figure using Patchwork ---

cat("\n--- Assembling final figure with patchwork ---\n")

# Arrange the 5 plots into a 2-row layout (3 on top, 2 on bottom)
# `plot_spacer()` adds an empty panel to balance the grid
final_figure <- (composition_plots_by_subpopulation$Transitional | composition_plots_by_subpopulation$Naive | composition_plots_by_subpopulation$IgM_Memory) /
                (composition_plots_by_subpopulation$Classical_Memory | composition_plots_by_subpopulation$DN | plot_spacer()) 

# Add overall annotations and collect the legends into one
final_figure_annotated <- final_figure + 
    plot_layout(guides = "collect") + # Collects legends into a single one
    plot_annotation(
        title = "Figure 1: Cellular Composition of B-Cell Clusters Aggregated Across Donors",
        subtitle = paste("Clusters are grouped by dominant phenotype. Data from donors:", paste(donors_to_plot, collapse=", ")),
        caption = "Each bar represents a cluster, ordered by purity from left to right within each panel.",
        tag_levels = 'A', # Automatically labels panels A, B, C, D, E
        theme = theme(
            plot.title = element_text(size = 28, face = "bold", hjust = 0.5),
            plot.subtitle = element_text(size = 18, hjust = 0.5),
            plot.caption = element_text(size = 14, face = "italic")
        )
    ) & 
    theme(legend.position = "bottom") # Ensure the collected legend is at the bottom

# Display the final figure in RStudio's plot viewer
print(final_figure_annotated)

# --- 6. Export the Final Figure in High Resolution ---

cat("\n--- Saving final figure to file ---\n")

ggsave(
    filename = "Poster_Figure_Composition.tiff", 
    plot = final_figure_annotated,
    width = 16,  # inches
    height = 10, # inches
    dpi = 300,   # dots per inch (standard for printing)
    device = 'tiff'
)

ggsave(
    filename = "Poster_Figure_Composition.pdf", 
    plot = final_figure_annotated,
    width = 16,
    height = 10,
    device = 'pdf'
)

cat("\n--- Script finished. Find your figure saved as 'Poster_Figure_Composition.tiff' and '.pdf' ---\n")
```

## Entropy Score

[Interpretation:]{.underline}

**Weighted Average Entropy**: Average sample mixedness per cell across all clusters.

  - Lower values (closer to 0) indicate clusters are, on average, less mixed with respect to Population.

```{r}
# citation("entropy")
```

**AMI Score:** Agreement between clustering and Population labels (range typically 0 to 1, higher is more agreement).

  - Lower values (closer to 0) suggest the clustering is more independent of Population (often desired after batch correction).

  - Higher values (closer to 1) suggest the clustering strongly reflects Population (could be biological difference or batch effect).

These scores can help compare different clustering runs (e.g., different resolutions or batch correction approaches).

#### Overall entropy scores

```{r}
# {r per_donor_entropy_on_AllHB_indep}

# Ensure necessary libraries are loaded
library(entropy)
library(aricode)

# --- Define Donors to Analyze ---
donors_to_analyze <- c("HB6", "HB34", "HB78")
results_list <- list() # Optional: uncomment to store results

cat("Calculating Per-Donor Entropy and AMI Scores from 'AllHB_indep'...\n")

# --- Loop Through Each Donor ---
for (donor_id in donors_to_analyze) {

  # 1. Subset the Seurat object for the current donor
  # The object name has been updated to AllHB_indep
  donor_specific_object <- subset(AllHB_indep, subset = orig.ident == donor_id)

  # Initialize scores to NA
  weighted_avg_entropy_donor <- NA
  ami_score_donor <- NA

  # Proceed only if cells are found for the donor
  if (ncol(donor_specific_object) > 0 && length(Idents(donor_specific_object)) > 0) {
    
    # Idents() will correctly use the independent cluster IDs you set up
    cluster_identities_donor <- Idents(donor_specific_object)
    original_samples_donor <- donor_specific_object$Population

    if (length(cluster_identities_donor) == length(original_samples_donor)) {
      
      # Calculate Weighted Average Entropy
      samples_split_by_cluster_donor <- split(original_samples_donor, cluster_identities_donor)
      samples_split_by_cluster_donor <- samples_split_by_cluster_donor[sapply(samples_split_by_cluster_donor, length) > 0]

      if (length(samples_split_by_cluster_donor) > 0) {
        individual_entropy_per_cluster_donor <- sapply(samples_split_by_cluster_donor, function(samples_in_cluster) {
          freq_table <- table(samples_in_cluster)
          prob_dist <- prop.table(freq_table)
          entropy::entropy(prob_dist, method = "ML", unit = "log")
        })

        clusters_present_for_entropy_donor <- names(individual_entropy_per_cluster_donor)
        cluster_counts_donor <- table(cluster_identities_donor)[clusters_present_for_entropy_donor]
        
        valid_counts_mask <- !is.na(cluster_counts_donor) & cluster_counts_donor > 0
        cluster_counts_donor <- cluster_counts_donor[valid_counts_mask]
        individual_entropy_per_cluster_donor <- individual_entropy_per_cluster_donor[names(cluster_counts_donor)]

        if (length(individual_entropy_per_cluster_donor) > 0 && 
            length(cluster_counts_donor) == length(individual_entropy_per_cluster_donor) && 
            sum(cluster_counts_donor) > 0) {
          weighted_avg_entropy_donor <- weighted.mean(individual_entropy_per_cluster_donor, cluster_counts_donor, na.rm = TRUE)
        }
      }
      
      # Calculate Adjusted Mutual Information (AMI)
      ami_score_donor <- aricode::AMI(as.character(cluster_identities_donor), as.character(original_samples_donor))
    }
  }

  # Print results for the current donor in a single line
  cat(sprintf("Donor: %-5s | Cells: %-5d | Avg Entropy: %.4f | AMI: %.4f\n", 
              donor_id, 
              ncol(donor_specific_object), 
              weighted_avg_entropy_donor, 
              ami_score_donor))

  # Optional: Store results
  results_list[[donor_id]] <- list(
    cells = ncol(donor_specific_object),
    weighted_entropy = weighted_avg_entropy_donor,
    ami = ami_score_donor
  )
}

cat("\nPer-donor calculations complete.\n")
```

Entropy Publication vs My analysis:

for tthe poster

```{r}
# --- 1. Load necessary libraries ---
# If you don't have these, install them with: install.packages(c("ggplot2", "tidyr"))
library(ggplot2)
library(tidyr)

# --- 2. Create the data frame ---
# We'll enter the data exactly as it appears in your image.
data <- data.frame(
  Donor = c("HB6", "HB34", "HB78", "HB6", "HB34", "HB78"),
  WAE_score = c(0.6116, 0.8498, 0.8135, 0.6040, 0.8607, 0.7911),
  AMI_score = c(0.4015, 0.3568, 0.3901, 0.4776, 0.4131, 0.4832),
  Analysis = c("Publication", "Publication", "Publication", "New analysis", "New analysis", "New analysis")
)

# --- 3. Reshape the data into a "long" format ---
# This format is ideal for plotting with ggplot2, with one column for the
# score type (WAE or AMI) and another for the corresponding value.
data_long <- data %>%
  pivot_longer(
    cols = c(WAE_score, AMI_score), 
    names_to = "Score_Type", 
    values_to = "Score_Value"
  )

# --- 4. Create the plot ---
# We will create a faceted plot, with one panel for WAE_score and one for AMI_score.
comparison_plot <- ggplot(data_long, aes(x = Donor, y = Score_Value, fill = Analysis)) +
  
  # Create grouped bars using geom_col()
  # position_dodge() places the bars for each analysis type side-by-side.
  geom_col(position = position_dodge(width = 0.9), alpha = 0.9) +
  
  # Add the numerical labels on top of each bar for clarity
  geom_text(
    aes(label = format(Score_Value, digits = 4)), 
    position = position_dodge(width = 0.9),
    vjust = -0.5, # Adjust vertical position to be just above the bar
    size = 3.5,
    fontface = "bold"
  ) +
  
  # Split the plot into two panels: one for AMI_score, one for WAE_score
  facet_wrap(~ Score_Type) +
  
  # Apply custom colors to match your image
  scale_fill_manual(values = c("New analysis" = "#0072B2", "Publication" = "#D55E00")) +
  
  # Add titles and labels for clarity
  labs(
    title = "Comparison of Scores Between Publication and New Analysis",
    subtitle = "Scores shown for each donor, grouped by analysis type",
    x = "Donor ID",
    y = "Score Value",
    fill = "Analysis Type" # Legend title
  ) +
  
  # Set the y-axis to start at 0 and expand slightly at the top
  scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.1))) +
  
  # Apply a clean and professional theme
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 18),
    plot.subtitle = element_text(size = 12, margin = margin(b = 15)),
    strip.text = element_text(face = "bold", size = 14), # Facet titles (WAE/AMI)
    panel.grid.major.x = element_blank(), # Remove vertical grid lines
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

# --- 5. Display the plot ---
print(comparison_plot)
```

# DEI POPULATIONS(AllHB/AllDonors)

### Object Suerat selected

Select the Seurat Object

```{r}
# 1. Selecting the Seurat Object for DEI:

# Object <- AllHB ; name_object <- "AllHB"
# Object <- Alldonors_object ; name_object <- "Alldonors_object"
 Object <- AllHB_indep   ; name_object <- "AllHB_indep" 
# Identifying Seurat Object:
cat("Seurat object is:", name_object, "\n") # Prints the name you set

cat("Working with Alldonors_object:\n")
print(Object) # Shows a summary of the object


DefaultAssay(Object) <- "RNA"
cat("Default assay for Object now set to: RNA\n")

# 2. Selecting number fo top genes to be considered in groups IG/TCR:
top_genes <- 10
n_top_genes <- top_genes # <-- CHANGE: Assign the value of top_genes here
cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number

```

DEI

differentially expressed markers is a core part of any single-cell analysis. The goal is to identify genes that are uniquely upregulated in each group of cells, defining that group's biological identity.

For your `AllHB` object, we can find the marker genes for each `Population` using the `FindAllMarkers` function in Seurat. Here is a step-by-step guide.

Step 1: Set the Active Identity

```{r}
# Set the active identity to the 'Population' column from your metadata
Idents(Object) <- "Population"

# You can check the levels to confirm it worked
# This should list: "Classical_Memory", "DN", "IgM_Memory", "Naive", "Transitional"
levels(Object)
```

### Step 2: Run FindAllMarkers

Now we can run the `FindAllMarkers` function. This function will compare each population against all other populations to find genes that are significantly upregulated. It is best practice to run differential expression on the `RNA` assay, not the `integrated` assay.

```{r}
# Find markers for every population compared to all remaining cells
all_population_markers <- FindAllMarkers(
  Object,
  assay = "RNA",           # IMPORTANT: Run on the non-integrated data
  only.pos = TRUE,         # Only report genes that are upregulated (positive markers)
  min.pct = 0.25,          # Test genes expressed in at least 25% of cells in the group
  logfc.threshold = 0.25   # Test genes with an average log2 fold change of at least 0.25
)
```

### Step 3: Find the Number of Statistically Different Genes

The `FindAllMarkers` output includes many genes, but now we need to filter them for statistical significance. We will filter for genes with an **adjusted p-value less than 0.05**. Then, we will count how many such genes exist for each population

```{r}
# Filter for significant markers (p_val_adj < 0.05) and count them for each population
significant_marker_counts <- all_population_markers %>%
  filter(p_val_adj < 0.05) %>%
  group_by(cluster) %>% # 'cluster' column contains the Population names
  summarise(number_of_markers = n())

# Print the resulting table
# This table shows you exactly how many significant marker genes were found for each population
print(significant_marker_counts)
```

If you want to speed up your future `FindAllMarkers` runs, you can install `presto` by running these two commands in your R console:

```{r}
# install.packages('devtools')
# devtools::install_github('immunogenomics/presto')
```

n_top_genes for each population:

```{r}
# Make sure dplyr is loaded
library(dplyr)

# Identifying Seurat Object adn number of top genes:
cat("Seurat object is:", name_object, "\n") # Prints the name you set
cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number
# Assuming 'all_population_markers' is your data frame from FindAllMarkers

# Find the top n_top_genes markers for each population based on log-fold change
topn_top_genes_markers_per_population <- all_population_markers %>%
  filter(p_val_adj < 0.05) %>%      # 1. First, keep only statistically significant markers
  group_by(cluster) %>%           # 2. Group the data frame by population ('cluster' column)
  slice_max(n = n_top_genes, order_by = avg_log2FC) # 3. For each group, select the n_top_genes rows with the highest avg_log2FC

# View the resulting table
# This will show the top n_top_genes markers for each population, all in one data frame
print(topn_top_genes_markers_per_population)
```

Some of the genes are not scaled, are not one of teh most variable. `DoHeatmap()` function needs to show relative expression levels (higher or lower than average), so it uses "scaled" data, which is stored in the `scale.data` slot of your Seurat object. BUt i only scales the genes you previously identified as variable features (e.g., the top 2000 genes found by `FindVariableFeatures`). However, your `FindAllMarkers` analysis searched through **all genes** to find markers. It's very likely that some of your top 10 markers for a given population were not in the original list of the top 2000 *most variable* genes.

##### **Gene Set Enrichment Analysis (GSEA)**,

Moving from finding marker genes to understanding the biological meaning behind them with pathway analysis is a crucial and exciting next step. A very common and powerful way to do this in R is using the `clusterProfiler` package. It can perform several types of enrichment analysis. We will focus on **Gene Set Enrichment Analysis (GSEA)**, which is generally preferred because it uses your entire ranked list of genes, not just an arbitrary list of "significant" ones. aThis process involves a few key steps: preparing your gene list, running the analysis against a biological database (like Gene Ontology), and visualizing the results.

The `clusterProfiler` package in R is an excellent tool for this. It connects to various biological databases to perform enrichment analysis. We will use it to perform **Gene Set Enrichment Analysis (GSEA)** against the **Gene Ontology (GO)** database

### Quantification Ig/TCR assocaited Gene Subgroups per Population

systematically check for the presence of specific gene families (Ig constant, V(D)J, etc.) within each of your FACS-defined populations. This can be done with a script that loops through each population in your `AllHB` object, gets the list of all genes expressed in that population, and then uses your predefined lists and regular expressions to find matches.

Genes:

```{r}
# Identifying Seurat Object and number of top genes:
cat("Seurat object is:", name_object, "\n") # Prints the name you set
cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number

# This script assumes your 'Object' Seurat object is loaded and ready.

# --- 1. Define Gene Lists and Patterns ---

# Explicit list of Ig constant genes and other specific genes
ig_constant_genes_list <- c(
  "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
  "IGHG1", "IGHG2", "IGHG3", "IGHG4",
  "IGKC",
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
  "AC233755.1" # Specific gene mentioned (encodes IGHV4-38-2)
)
# Convert to a character vector for efficient lookup
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
# Anchored to the start (^) to avoid partial matches
ig_vdj_regex <- "^IG[HKL][VDJ]" # Ig V(D)J genes (Heavy, Kappa, Lambda)
igll_regex <- "^IGLL"           # IGLL genes
tcr_regex <- "^TR[ABGD][CV]"    # TCR V/C genes (Alpha, Beta, Gamma, Delta)


# --- 2. Prepare for Analysis ---

# Set the active identity to the 'Population' column to easily loop through them
Idents(Object) <- "Population"

# Get the names of all populations present in the object
populations_to_analyze <- levels(Object)

# Create an empty data frame to store the summary counts
gene_counts_summary <- data.frame(
  Population = character(),
  Constant_Ig = integer(),
  VDJ_Ig = integer(),
  IGLL = integer(),
  TCR = integer(),
  stringsAsFactors = FALSE
)

cat("--- Starting gene subgroup detection for each population in Object ---\n")


# --- 3. Loop Through Each Population and Count Genes ---

for (pop_name in populations_to_analyze) {
  
  cat(paste0("\n--- Analyzing Population: ", pop_name, " ---\n"))
  
  # A. Subset the main Seurat object to get only the cells for the current population
  population_subset_obj <- subset(Object, idents = pop_name)
  
  # B. Get all features (genes) present in the RNA assay for this subset
  expressed_genes <- rownames(GetAssay(population_subset_obj, assay = "RNA"))
  
  # C. Detect genes for each category and get the count
  
  # Find and count the constant Ig genes
  found_constant_genes_count <- length(intersect(ig_constant_genes_set, expressed_genes))
  
  # Find and count V(D)J genes using the regular expression
  found_vdj_genes_count <- length(grep(ig_vdj_regex, expressed_genes, value = TRUE))
  
  # Find and count IGLL genes
  found_igll_genes_count <- length(grep(igll_regex, expressed_genes, value = TRUE))
  
  # Find and count TCR genes
  found_tcr_genes_count <- length(grep(tcr_regex, expressed_genes, value = TRUE))
  
  
  # D. Store and Report the Counts for the Current Population
  
  # Create a temporary data frame row with the new counts
  new_row <- data.frame(
    Population = pop_name,
    Constant_Ig = found_constant_genes_count,
    VDJ_Ig = found_vdj_genes_count,
    IGLL = found_igll_genes_count,
    TCR = found_tcr_genes_count
  )
  
  # Add the new row to our summary data frame
  gene_counts_summary <- bind_rows(gene_counts_summary, new_row)
  
  # Print a summary to the console for immediate review
  cat(sprintf("  Counts: Constant_Ig=%d, VDJ_Ig=%d, IGLL=%d, TCR=%d\n",
              found_constant_genes_count,
              found_vdj_genes_count,
              found_igll_genes_count,
              found_tcr_genes_count))
  
}

cat("\n--- Gene subgroup detection complete. ---\n")


# --- 4. Display the Final Summary Table ---

# Print the final data frame with all results
cat("\nFinal Gene Counts Summary:\n")
print(gene_counts_summary)


```

Cells:

```{r}
# Identifying Seurat Object and number of top genes:
cat("Seurat object is:", name_object, "\n") # Prints the name you set
cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number

# This script assumes your 'AllHB' Seurat object is loaded and ready.

# --- 1. Define Gene Lists and Patterns ---

# Explicit list of Ig constant genes and other specific genes
ig_constant_genes_list <- c(
  "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
  "IGHG1", "IGHG2", "IGHG3", "IGHG4",
  "IGKC",
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
  "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"


# --- 2. Find All Matching Genes in the Full Object ---
# This is more efficient than running grep inside the loop.
all_genes_in_object <- rownames(Object)

# Get the full list of genes in the object that match each category
constant_genes_in_object <- intersect(ig_constant_genes_set, all_genes_in_object)
vdj_genes_in_object <- grep(ig_vdj_regex, all_genes_in_object, value = TRUE)
igll_genes_in_object <- grep(igll_regex, all_genes_in_object, value = TRUE)
tcr_genes_in_object <- grep(tcr_regex, all_genes_in_object, value = TRUE)


# --- 3. Prepare for Analysis ---

# Set the active identity to 'Population' to loop through them
Idents(Object) <- "Population"
populations_to_analyze <- levels(Object)

# Create an empty data frame to store the final cell counts
cell_counts_summary <- data.frame(
  Population = character(),
  Total_Cells = integer(),
  Cells_Expressing_Constant_Ig = integer(),
  Cells_Expressing_VDJ_Ig = integer(),
  Cells_Expressing_IGLL = integer(),
  Cells_Expressing_TCR = integer(),
  stringsAsFactors = FALSE
)

cat("--- Starting cell counting for each gene subgroup per population ---\n")


# --- 4. Loop Through Each Population and Count Cells ---

for (pop_name in populations_to_analyze) {
  
  cat(paste0("\n--- Analyzing Population: ", pop_name, " ---\n"))
  
  # A. Get the expression data for the current population
  # We work directly with the count matrix for efficiency.
  count_matrix_subset <- GetAssayData(Object, assay = "RNA", slot = "counts")[, WhichCells(Object, idents = pop_name)]
  
  # B. For each gene group, count how many cells express at least one gene from that group
  
  # The logic is:
  # 1. Subset the count matrix to only include genes from our target group.
  # 2. Use colSums() to get the total counts of that gene group for each cell.
  # 3. A cell is "expressing" if its total count (colSums) is > 0.
  # 4. Sum the logical vector (TRUE/FALSE) to get the final cell count.
  
  # Count cells expressing Constant Ig genes
  constant_ig_counts <- count_matrix_subset[intersect(constant_genes_in_object, rownames(count_matrix_subset)), , drop = FALSE]
  cells_w_constant_ig <- sum(colSums(constant_ig_counts) > 0)
  
  # Count cells expressing V(D)J genes
  vdj_ig_counts <- count_matrix_subset[intersect(vdj_genes_in_object, rownames(count_matrix_subset)), , drop = FALSE]
  cells_w_vdj_ig <- sum(colSums(vdj_ig_counts) > 0)

  # Count cells expressing IGLL genes
  igll_counts <- count_matrix_subset[intersect(igll_genes_in_object, rownames(count_matrix_subset)), , drop = FALSE]
  cells_w_igll <- sum(colSums(igll_counts) > 0)

  # Count cells expressing TCR genes
  tcr_counts <- count_matrix_subset[intersect(tcr_genes_in_object, rownames(count_matrix_subset)), , drop = FALSE]
  cells_w_tcr <- sum(colSums(tcr_counts) > 0)

  
  # C. Store the results for this population
  new_row <- data.frame(
    Population = pop_name,
    Total_Cells = ncol(count_matrix_subset),
    Cells_Expressing_Constant_Ig = cells_w_constant_ig,
    Cells_Expressing_VDJ_Ig = cells_w_vdj_ig,
    Cells_Expressing_IGLL = cells_w_igll,
    Cells_Expressing_TCR = cells_w_tcr
  )
  
  cell_counts_summary <- bind_rows(cell_counts_summary, new_row)
}

cat("\n--- Cell counting complete. ---\n")


# --- 5. Display the Final Summary Table in the Desired Order ---

# Define the desired order of populations
desired_population_category_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Reorder the summary table based on the desired population order
# We do this by converting the 'Population' column to a factor with the specified levels
# and then arranging the data frame based on that factor.
cell_counts_summary <- cell_counts_summary %>%
  mutate(Population = factor(Population, levels = desired_population_category_order)) %>%
  arrange(Population)


cat("\nSummary of Cells Expressing Gene Subgroups (sorted):\n")
print(cell_counts_summary)



```

## Expression of B Cell Markers and Ig Isotypes

gene expression patterns in your `Seurat`object match the expected canonical markers

#### Short list of genes

```{r}
# Identifying Seurat Object and number of top genes:
cat("Seurat object is:", name_object, "\n") # Prints the name you set
cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number

# This script assumes your Object (i.e. 'AllHB') Seurat object is loaded and ready.

# --- 1. Define the List of Genes to Plot ---

# We will use the specific list of markers from your example image,
# and have kept the light chains as well.
genes_to_plot <- c(
    # --- Markers from Example Image ---
    "CD27", "CD19", "MS4A1",
    "IGHM", "IGHD", "IGHE", 
    "IGHG1", "IGHG2", "IGHG3", "IGHG4", 
    "IGHA1", "IGHA2",
    
    # --- Light Chains (from previous version) ---
    "IGKC", "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7"
)

# Check which of these genes are actually present in your object to avoid errors
genes_to_plot <- intersect(genes_to_plot, rownames(Object))

cat("Will plot the following found genes:\n")
print(genes_to_plot)


# --- 2. Prepare the Seurat Object for Plotting ---

# A. Set the active identity to 'Population' to group the cells correctly
Idents(Object) <- "Population"

# B. Set the order of the populations on the plot
desired_population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Reorder the identity levels to match our desired order
Object@active.ident <- factor(Object@active.ident, levels = desired_population_order)


# --- 3. Create the Dot Plot ---

cat("\nGenerating Dot Plot with custom colors...\n")

# Create the plot using the defined genes and population order
marker_dot_plot <- DotPlot(
    Object,
    features = genes_to_plot,
    assay = "RNA" # Use the RNA assay for expression levels
) +
  # --- Add custom color gradient to match the example ---
  # This creates the blue -> white/yellow -> red diverging color scale.
  scale_colour_gradient2(low = "#4575B4", mid = "#FFFFBF", high = "#D73027") +
  labs(
    # Append the object's string name to the title
    title = paste0("Expression of B Cell Markers and Ig Isotypes in: ", name_object),
    subtitle = "Across FACS-defined Populations"
  ) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, face = "italic"), # Rotate x-axis labels for readability
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

print(marker_dot_plot)
# Identifying Seurat Object:
cat("Seurat object is:", name_object, "\n") # Prints the name you set
```

#### No IGHD

Objecthave all the markers (including IgHD).

```{r}
# This will return TRUE if "IGHD" is in your object, and FALSE if it is not.
"IGHD" %in% rownames(Object)
"CD19" %in% rownames(Object)
"MME" %in% rownames(Object)
"CD27" %in% rownames(Object)
```

#### All IG/TCR associated genes

Grouping according to IG/TCR genes:

```{r}
# Identifying Seurat Object and number of top genes:
cat("Seurat object is:", name_object, "\n") # Prints the name you set
cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number

# --- 1. Define the List of Genes to Plot ---

# A. Define the explicit list of constant genes and regex patterns
ig_constant_genes_list <- c(
    "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
    "IGHG1", "IGHG2", "IGHG3", "IGHG4",
    "IGKC",
    "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
    "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"

# B. Find all genes in the object that match the regex patterns
all_genes_in_object <- rownames(Object)
vdj_genes_found <- grep(ig_vdj_regex, all_genes_in_object, value = TRUE)
igll_genes_found <- grep(igll_regex, all_genes_in_object, value = TRUE)
tcr_genes_found <- grep(tcr_regex, all_genes_in_object, value = TRUE)

# C. Combine all gene lists into a single, unique list for plotting
genes_to_plot <- unique(c(
    ig_constant_genes_set,
    vdj_genes_found,
    igll_genes_found,
    tcr_genes_found
))

# D. Final safety check: ensure all selected genes are actually in the object
genes_to_plot <- intersect(genes_to_plot, all_genes_in_object)

cat("Will plot the following", length(genes_to_plot), "found genes:\n")
# print(genes_to_plot) # Uncomment to see the full list of genes being plotted


# --- 2. Prepare the Seurat Object for Plotting ---

# A. Set the active identity to 'Population' to group the cells correctly
Idents(Object) <- "Population"

# B. Set the order of the populations on the plot
desired_population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Reorder the identity levels to match our desired order
Object@active.ident <- factor(Object@active.ident, levels = desired_population_order)


# --- 3. Create the Dot Plot ---

cat("\nGenerating Dot Plot with custom colors...\n")

# Create the plot using the defined genes and population order
marker_dot_plot <- DotPlot(
    Object, 
    features = genes_to_plot,
    assay = "RNA" # Use the RNA assay for expression levels
  ) +
  # --- Add custom color gradient to match the example ---
  # This creates the blue -> white/yellow -> red diverging color scale.
  scale_colour_gradient2(low = "#4575B4", mid = "#FFFFBF", high = "#D73027") +
  labs(
    title = paste0("Expression of Ig/TCR associated genes: ", name_object),
    subtitle = paste0("Number of top genes considered: ", n_top_genes)
  ) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, face = "italic",size = 8), # Rotate x-axis labels for readability
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "top" # Move legend to the top
  )

print(marker_dot_plot)

# Load necessary libraries
library(Seurat)
library(ggplot2)
library(dplyr)

# This script assumes your 'AllHB' Seurat object is loaded and ready.

# --- 1. Define the List of Genes to Plot ---

# A. Define the explicit list of constant genes and regex patterns
ig_constant_genes_list <- c(
    "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
    "IGHG1", "IGHG2", "IGHG3", "IGHG4",
    "IGKC",
    "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
    "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"

# B. Find all genes in the object that match the regex patterns
all_genes_in_object <- rownames(Object)
vdj_genes_found <- grep(ig_vdj_regex, all_genes_in_object, value = TRUE)
igll_genes_found <- grep(igll_regex, all_genes_in_object, value = TRUE)
tcr_genes_found <- grep(tcr_regex, all_genes_in_object, value = TRUE)

# C. Combine all gene lists into a single, unique list for plotting
genes_to_plot <- unique(c(
    ig_constant_genes_set,
    vdj_genes_found,
    igll_genes_found,
    tcr_genes_found
))

# D. Final safety check: ensure all selected genes are actually in the object
genes_to_plot <- intersect(genes_to_plot, all_genes_in_object)

cat("Will plot the following", length(genes_to_plot), "found genes:\n")
# print(genes_to_plot) # Uncomment to see the full list of genes being plotted


# --- 2. Prepare the Seurat Object for Plotting ---

# A. Set the active identity to 'Population' to group the cells correctly
Idents(Object) <- "Population"

# B. Set the order of the populations on the plot
desired_population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Reorder the identity levels to match our desired order
Object@active.ident <- factor(Object@active.ident, levels = desired_population_order)


# --- 3. Create the Dot Plot ---

cat("\nGenerating Dot Plot with custom colors...\n")

# Create the plot using the defined genes and population order
marker_dot_plot <- DotPlot(
    Object, 
    features = genes_to_plot,
    assay = "RNA" # Use the RNA assay for expression levels
  ) +
  # --- Add custom color gradient to match the example ---
  # This creates the blue -> white/yellow -> red diverging color scale.
  scale_colour_gradient2(low = "#4575B4", mid = "#FFFFBF", high = "#D73027") +
  # --- Flip the coordinates to put features on the y-axis ---
  coord_flip() +
  labs(
    title = paste0("Expression of Ig/TCR associated genes: ", name_object),
    subtitle = paste0("Number of top genes considered: ", n_top_genes)
  ) +
  theme(
    # After flipping, the x-axis now has the populations, which don't need rotation.
    # The y-axis now has the features, so we apply the italic style and reduce the size here.
    axis.text.y = element_text(face = "italic", size = 6), 
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "top" # Move legend to the top
  )

print(marker_dot_plot)


# --- 4. Find Most Relevant Genes Programmatically ---

cat("\n--- Finding top relevant genes for each population from the dot plot data ---\n")

# A. Extract the data used to generate the plot
plot_data <- marker_dot_plot$data

# B. Find the top genes for each population based on average expression (color)
top_expressed_genes <- plot_data %>%
  group_by(id) %>% # The 'id' column contains the Population names
  slice_max(n = n_top_genes, order_by = avg.exp.scaled, with_ties = FALSE) %>%
  select(id, features.plot, avg.exp.scaled) # Select relevant columns

cat("\nTop Genes by Average Expression (Color of Dot):\n")
print(as.data.frame(top_expressed_genes))


# C. Find the top genes for each population based on percent expressed (size)
top_percent_genes <- plot_data %>%
  group_by(id) %>%
  slice_max(n = n_top_genes, order_by = pct.exp, with_ties = FALSE) %>%
  select(id, features.plot, pct.exp)

cat("\nTop Genes by Percent Expressed (Size of Dot):\n")
print(as.data.frame(top_percent_genes))


```

#### Ig Grouped genes (% and average expression)

It stated Seurat object used and number of top genes

```{r}
# Identifying Seurat Object and number of top genes:
cat("Seurat object is:", name_object, "\n") # Prints the name you set
cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number

# --- 1. Define the List of Genes to Plot ---

# A. Define the explicit list of constant genes and regex patterns
ig_constant_genes_list <- c(
    "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
    "IGHG1", "IGHG2", "IGHG3", "IGHG4",
    "IGKC",
    "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
    "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"

# B. Find all genes in the object that match the regex patterns
all_genes_in_object <- rownames(Object)
vdj_genes_found <- grep(ig_vdj_regex, all_genes_in_object, value = TRUE)
igll_genes_found <- grep(igll_regex, all_genes_in_object, value = TRUE)
tcr_genes_found <- grep(tcr_regex, all_genes_in_object, value = TRUE)
constant_genes_found <- intersect(ig_constant_genes_set, all_genes_in_object)

# C. Print the lists of found genes by category
cat("\n--- Genes Found by Category ---\n")
cat("Constant Ig Genes found in object:\n")
if(length(constant_genes_found) > 0) {
  cat(" ", paste(constant_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("VDJ Ig Genes found by regex:\n")
if(length(vdj_genes_found) > 0) {
  cat(" ", paste(vdj_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("IGLL Genes found by regex:\n")
if(length(igll_genes_found) > 0) {
  cat(" ", paste(igll_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("TCR Genes found by regex:\n")
if(length(tcr_genes_found) > 0) {
  cat(" ", paste(tcr_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("----------------------------------\n\n")


# D. Combine all gene lists into a single, unique list for plotting
genes_to_plot <- unique(c(
    constant_genes_found, # Use the found genes, not the full definition
    vdj_genes_found,
    igll_genes_found,
    tcr_genes_found
))

# E. Final safety check: ensure all selected genes are actually in the object
genes_to_plot <- intersect(genes_to_plot, all_genes_in_object)

cat("Will plot the following", length(genes_to_plot), "found genes:\n")
# print(genes_to_plot) # Uncomment to see the full list of genes being plotted


# --- 2. Prepare the Seurat Object for Plotting ---

# A. Set the active identity to 'Population' to group the cells correctly
Idents(Object) <- "Population"

# B. Set the order of the populations on the plot
desired_population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Reorder the identity levels to match our desired order
Object@active.ident <- factor(Object@active.ident, levels = desired_population_order)


# --- 3. Create the Dot Plot ---

cat("\nGenerating Dot Plot with custom colors...\n")

# Create the plot using the defined genes and population order
marker_dot_plot <- DotPlot(
    Object, 
    features = genes_to_plot,
    assay = "RNA" # Use the RNA assay for expression levels
  ) +
  # --- Add custom color gradient to match the example ---
  scale_colour_gradient2(low = "#4575B4", mid = "#FFFFBF", high = "#D73027") +
  labs(
    title = paste0("Expression of Ig/TCR associated genes: ", name_object),
    subtitle = paste0("Number of top genes considered: ", n_top_genes)
  ) +
  theme(
    # Revert to rotating the x-axis labels, as features are on the x-axis again
    axis.text.x = element_text(angle = 90, hjust = 1, face = "italic"),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "top"
  )

print(marker_dot_plot)


# --- 4. Find Most Relevant Genes Programmatically ---

cat("\n--- Finding top most relevant genes for each population from the dot plot data ---\n")

# A. Create a lookup table for gene categories
gene_category_df <- bind_rows(
    if(length(constant_genes_found) > 0) tibble(gene = constant_genes_found, category = "Constant Ig"),
    if(length(vdj_genes_found) > 0) tibble(gene = vdj_genes_found, category = "VDJ Ig"),
    if(length(igll_genes_found) > 0) tibble(gene = igll_genes_found, category = "IGLL"),
    if(length(tcr_genes_found) > 0) tibble(gene = tcr_genes_found, category = "TCR")
) %>% distinct(gene, .keep_all = TRUE) # Ensure each gene has only one category

# B. Extract the data used to generate the plot
plot_data <- marker_dot_plot$data

# C. Find the top genes for each population based on average expression (color)
top_expressed_genes <- plot_data %>%
  group_by(id) %>% # The 'id' column contains the Population names
  slice_max(n = n_top_genes, order_by = avg.exp.scaled, with_ties = FALSE) %>%
  left_join(gene_category_df, by = c("features.plot" = "gene")) %>% # Add the category info
  select(id, features.plot, category, avg.exp.scaled) # Select relevant columns

cat("\nTop Genes by Average Expression (Color of Dot):\n")
print(as.data.frame(top_expressed_genes))


# D. Find the top genes for each population based on percent expressed (size)
top_percent_genes <- plot_data %>%
  group_by(id) %>%
  slice_max(n = n_top_genes, order_by = pct.exp, with_ties = FALSE) %>%
  left_join(gene_category_df, by = c("features.plot" = "gene")) %>% # Add the category info
  select(id, features.plot, category, pct.exp)

cat("\nTop genes by Percent Expressed (Size of Dot):\n")
print(as.data.frame(top_percent_genes))
```

#### Ig Grouped genes (% and average expression and Fraction of total)

Groups in numbers:

```{r}
# Load necessary libraries
library(Seurat)
library(ggplot2)
library(dplyr)
library(tidyr) # For pivot_wider

# Selecting number fo top genes to be considered in groups IG/TCR:

cat("Number top genes in Ig/TCr groups is:", n_top_genes, "\n") # This will now print the number

# --- 1. Define the List of Genes to Plot ---

# A. Define the explicit list of constant genes and regex patterns
ig_constant_genes_list <- c(
    "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
    "IGHG1", "IGHG2", "IGHG3", "IGHG4",
    "IGKC",
    "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
    "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"

# B. Find all genes in the object that match the regex patterns
all_genes_in_object <- rownames(Object)
vdj_genes_found <- grep(ig_vdj_regex, all_genes_in_object, value = TRUE)
igll_genes_found <- grep(igll_regex, all_genes_in_object, value = TRUE)
tcr_genes_found <- grep(tcr_regex, all_genes_in_object, value = TRUE)
constant_genes_found <- intersect(ig_constant_genes_set, all_genes_in_object)

# C. Print the lists of found genes by category
cat("\n--- Genes Found by Category ---\n")
cat("Constant Ig Genes found in object:\n")
if(length(constant_genes_found) > 0) {
  cat(" ", paste(constant_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("VDJ Ig Genes found by regex:\n")
if(length(vdj_genes_found) > 0) {
  cat(" ", paste(vdj_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("IGLL Genes found by regex:\n")
if(length(igll_genes_found) > 0) {
  cat(" ", paste(igll_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("TCR Genes found by regex:\n")
if(length(tcr_genes_found) > 0) {
  cat(" ", paste(tcr_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("----------------------------------\n\n")


# D. Combine all gene lists into a single, unique list for plotting
genes_to_plot <- unique(c(
    constant_genes_found, # Use the found genes, not the full definition
    vdj_genes_found,
    igll_genes_found,
    tcr_genes_found
))

# E. Final safety check: ensure all selected genes are actually in the object
genes_to_plot <- intersect(genes_to_plot, all_genes_in_object)

cat("Will plot the following", length(genes_to_plot), "found genes:\n")
# print(genes_to_plot) # Uncomment to see the full list of genes being plotted


# --- 2. Prepare the Seurat Object for Plotting ---

# A. Set the active identity to 'Population' to group the cells correctly
Idents(Object) <- "Population"

# B. Set the order of the populations on the plot
desired_population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Reorder the identity levels to match our desired order
Object@active.ident <- factor(Object@active.ident, levels = desired_population_order)


# --- 3. Create the Dot Plot ---

cat("\nGenerating Dot Plot with custom colors...\n")

# Create the plot using the defined genes and population order
marker_dot_plot <- DotPlot(
    Object, 
    features = genes_to_plot,
    assay = "RNA" # Use the RNA assay for expression levels
  ) +
  # --- Add custom color gradient to match the example ---
  scale_colour_gradient2(low = "#4575B4", mid = "#FFFFBF", high = "#D73027") +
  labs(
    title = paste0("Expression of Ig/TCR associated genes: ", name_object),
    subtitle = paste0("Number of top genes considered: ", n_top_genes)
  ) +
  theme(
    # Revert to rotating the x-axis labels, as features are on the x-axis again
    axis.text.x = element_text(angle = 90, hjust = 1, face = "italic"),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "top"
  )

print(marker_dot_plot)


# --- 4. Find Most Relevant Genes Programmatically ---

cat("\n--- Finding top most relevant genes for each population from the dot plot data ---\n")

# A. Create a lookup table for gene categories
gene_category_df <- bind_rows(
    if(length(constant_genes_found) > 0) tibble(gene = constant_genes_found, category = "Constant Ig"),
    if(length(vdj_genes_found) > 0) tibble(gene = vdj_genes_found, category = "VDJ Ig"),
    if(length(igll_genes_found) > 0) tibble(gene = igll_genes_found, category = "IGLL"),
    if(length(tcr_genes_found) > 0) tibble(gene = tcr_genes_found, category = "TCR")
) %>% distinct(gene, .keep_all = TRUE) # Ensure each gene has only one category

# B. Extract the data used to generate the plot
plot_data <- marker_dot_plot$data

# C. Find the top genes for each population based on average expression (color)
top_expressed_genes <- plot_data %>%
  group_by(id) %>% # The 'id' column contains the Population names
  slice_max(n = n_top_genes, order_by = avg.exp.scaled, with_ties = FALSE) %>%
  left_join(gene_category_df, by = c("features.plot" = "gene")) %>% # Add the category info
  select(id, features.plot, category, avg.exp.scaled) # Select relevant columns

cat("\nTop Genes by Average Expression (Color of Dot):\n")
print(as.data.frame(top_expressed_genes))


# D. Find the top genes for each population based on percent expressed (size)
top_percent_genes <- plot_data %>%
  group_by(id) %>%
  slice_max(n = n_top_genes, order_by = pct.exp, with_ties = FALSE) %>%
  left_join(gene_category_df, by = c("features.plot" = "gene")) %>% # Add the category info
  select(id, features.plot, category, pct.exp)

cat("\nTop Genes by Percent Expressed (Size of Dot):\n")
print(as.data.frame(top_percent_genes))


# --- 5. Create Summary Data Frame of Top Gene Categories ---

cat("\n--- Summarizing categories of top  genes ---\n")

# A. Summarize the categories for the 'Top genes by Average Expression' list
category_summary_by_expression <- top_expressed_genes %>%
  group_by(id, category) %>% # Group by population and category
  summarise(count = n(), .groups = 'drop') %>% # Count the number of genes in each category
  pivot_wider(names_from = category, values_from = count, values_fill = 0) # Reshape to wide format

cat("\nSummary of Top Gene Categories (by Avg. Expression):\n")
print(as.data.frame(category_summary_by_expression))


# B. Summarize the categories for the 'Top genes by Percent Expressed' list
category_summary_by_percent <- top_percent_genes %>%
  group_by(id, category) %>% # Group by population and category
  summarise(count = n(), .groups = 'drop') %>% # Count the number of genes in each category
  pivot_wider(names_from = category, values_from = count, values_fill = 0) # Reshape to wide format

cat("\nSummary of Top Genes Categories (by Pct. Expressed):\n")
print(as.data.frame(category_summary_by_percent))

```

#### Ig Grouped genes (% and average expression and Graph Fraction of total)

Groups in numbers: Using pie charts

```{r}
# Load necessary libraries
library(Seurat)
library(ggplot2)
library(dplyr)
library(tidyr) # For pivot_wider

# This script assumes your 'AllHB' Seurat object is loaded and ready.

# --- 1. Define the List of Genes to Plot ---

# A. Define the explicit list of constant genes and regex patterns
ig_constant_genes_list <- c(
    "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
    "IGHG1", "IGHG2", "IGHG3", "IGHG4",
    "IGKC",
    "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
    "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))

# Regular expression patterns for different gene categories
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"

# B. Find all genes in the object that match the regex patterns
all_genes_in_object <- rownames(Object)
vdj_genes_found <- grep(ig_vdj_regex, all_genes_in_object, value = TRUE)
igll_genes_found <- grep(igll_regex, all_genes_in_object, value = TRUE)
tcr_genes_found <- grep(tcr_regex, all_genes_in_object, value = TRUE)
constant_genes_found <- intersect(ig_constant_genes_set, all_genes_in_object)

# C. Print the lists of found genes by category
cat("\n--- Genes Found by Category ---\n")
cat("Constant Ig Genes found in object:\n")
if(length(constant_genes_found) > 0) {
  cat(" ", paste(constant_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("VDJ Ig Genes found by regex:\n")
if(length(vdj_genes_found) > 0) {
  cat(" ", paste(vdj_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("IGLL Genes found by regex:\n")
if(length(igll_genes_found) > 0) {
  cat(" ", paste(igll_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("TCR Genes found by regex:\n")
if(length(tcr_genes_found) > 0) {
  cat(" ", paste(tcr_genes_found, collapse = ", "), "\n")
} else {
  cat("  None\n")
}
cat("----------------------------------\n\n")


# D. Combine all gene lists into a single, unique list for plotting
genes_to_plot <- unique(c(
    constant_genes_found, # Use the found genes, not the full definition
    vdj_genes_found,
    igll_genes_found,
    tcr_genes_found
))

# E. Final safety check: ensure all selected genes are actually in the object
genes_to_plot <- intersect(genes_to_plot, all_genes_in_object)

cat("Will plot the following", length(genes_to_plot), "found genes:\n")
# print(genes_to_plot) # Uncomment to see the full list of genes being plotted


# --- 2. Prepare the Seurat Object for Plotting ---

# A. Set the active identity to 'Population' to group the cells correctly
Idents(Object) <- "Population"

# B. Set the order of the populations on the plot
desired_population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Reorder the identity levels to match our desired order
Object@active.ident <- factor(Object@active.ident, levels = desired_population_order)


# --- 3. Create the Dot Plot ---

cat("\nGenerating Dot Plot with custom colors...\n")

# Create the plot using the defined genes and population order
marker_dot_plot <- DotPlot(
    Object, 
    features = genes_to_plot,
    assay = "RNA" # Use the RNA assay for expression levels
  ) +
  # --- Add custom color gradient to match the example ---
  scale_colour_gradient2(low = "#4575B4", mid = "#FFFFBF", high = "#D73027") +
  labs(
    title = paste0("Expression of Ig/TCR associated genes: ", name_object),
    subtitle = paste0("Number of top genes considered: ", n_top_genes)
  ) +
  theme(
    # Revert to rotating the x-axis labels, as features are on the x-axis again
    axis.text.x = element_text(angle = 90, hjust = 1, face = "italic"),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "top"
  )

print(marker_dot_plot)


# --- 4. Find Most Relevant Genes Programmatically ---

cat("\n--- Finding top most relevant genes for each population from the dot plot data ---\n")

# A. Create a lookup table for gene categories
gene_category_df <- bind_rows(
    if(length(constant_genes_found) > 0) tibble(gene = constant_genes_found, category = "Constant Ig"),
    if(length(vdj_genes_found) > 0) tibble(gene = vdj_genes_found, category = "VDJ Ig"),
    if(length(igll_genes_found) > 0) tibble(gene = igll_genes_found, category = "IGLL"),
    if(length(tcr_genes_found) > 0) tibble(gene = tcr_genes_found, category = "TCR")
) %>% distinct(gene, .keep_all = TRUE) # Ensure each gene has only one category

# B. Extract the data used to generate the plot
plot_data <- marker_dot_plot$data

# C. Find the top genes for each population based on average expression (color)
top_expressed_genes <- plot_data %>%
  group_by(id) %>% # The 'id' column contains the Population names
  slice_max(n = n_top_genes, order_by = avg.exp.scaled, with_ties = FALSE) %>%
  left_join(gene_category_df, by = c("features.plot" = "gene")) %>% # Add the category info
  select(id, features.plot, category, avg.exp.scaled) # Select relevant columns

# D. Find the top genes for each population based on percent expressed (size)
top_percent_genes <- plot_data %>%
  group_by(id) %>%
  slice_max(n = n_top_genes, order_by = pct.exp, with_ties = FALSE) %>%
  left_join(gene_category_df, by = c("features.plot" = "gene")) %>% # Add the category info
  select(id, features.plot, category, pct.exp)


# --- 5. Create Pie Chart Summaries of Top Gene Categories ---

cat("\n--- Generating pie charts to summarize categories of top genes ---\n")

# A. Summarize and plot the categories for the 'by Avg. Expression' list
category_summary_by_expression <- top_expressed_genes %>%
  group_by(id, category) %>%
  summarise(count = n(), .groups = 'drop') %>%
  # Fill in NA categories with 0 for plotting
  mutate(category = ifelse(is.na(category), "Uncategorized", category))

pie_chart_expression <- ggplot(category_summary_by_expression, aes(x = "", y = count, fill = category)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) + # This turns the bar chart into a pie chart
  facet_wrap(~id) + # Create a separate chart for each population
  theme_void() + # Remove background, axes, etc. for a clean look
  labs(title = paste0("Expression of Ig/TCR associated genes by top Avg. Expression: ", name_object),
    subtitle = paste0("Number of top genes considered: ", n_top_genes)) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(pie_chart_expression)


# B. Summarize and plot the categories for the 'Top genes by Percent Expressed' list
category_summary_by_percent <- top_percent_genes %>%
  group_by(id, category) %>%
  summarise(count = n(), .groups = 'drop') %>%
  mutate(category = ifelse(is.na(category), "Uncategorized", category))
  
pie_chart_percent <- ggplot(category_summary_by_percent, aes(x = "", y = count, fill = category)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  facet_wrap(~id) +
  theme_void() +
  labs(title = paste0("Expression of Ig/TCR associated genes by top Percent Expressed: ", name_object),
    subtitle = paste0("Number of top genes considered: ", n_top_genes)) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(pie_chart_percent)


```

## DEI Clusters (AllHB_indep)

let check the object:

```{r}
head(AllHB@meta.data)
```

```{r}
head(AllHB_indep@meta.data)
```

UMAP representation:

```{r}
# Use the newly named object as input for the plot
plot_independent_clusters <- DimPlot(AllHB_indep, # <- Renamed variable
                                     reduction = "umap", 
                                     split.by = "orig.ident", 
                                     label = TRUE, 
                                     repel = TRUE)

print(plot_independent_clusters)
```

Rename seurat clusters in AllHB_indep

```{r}
# {r rename_and_plot_independent_clusters}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)

# This script correctly renames independently run clusters for each donor
# and then generates the updated DimPlot.
# It assumes your 'AllHB_indep' Seurat object is loaded.

cat("--- Starting Donor-Specific Cluster Renaming ---\n")

# 1. Create a temporary, unique ID for each cluster within each donor directly in the object
# This combines 'orig.ident' and 'seurat_clusters' (e.g., "HB6_0", "HB34_1")
AllHB_indep$ind_cluster_id <- paste(AllHB_indep$orig.ident, AllHB_indep$seurat_clusters, sep = "_")

# 2. Extract metadata for mapping. Now it includes the new 'ind_cluster_id' column.
meta <- AllHB_indep@meta.data

# 3. Calculate the most prevalent population for each independent cluster
# We use dplyr to group by our new ID and count populations.
prevalent_pop_map <- meta %>%
  group_by(ind_cluster_id) %>%
  count(Population, name = "count") %>% # Count cells of each Population in each ind_cluster_id
  top_n(1, count) %>%       # Keep only the top population (most numerous)
  slice(1) %>%              # In case of a tie, just pick the first one
  ungroup()

# 4. Create the new, final labels by combining the ID and the prevalent population
prevalent_pop_map <- prevalent_pop_map %>%
  mutate(new_label = paste(ind_cluster_id, Population, sep = "_"))

# 5. Create a named vector for easy mapping of old IDs to new labels
# This is a robust way to assign the new names back to the cells.
rename_vec <- prevalent_pop_map$new_label
names(rename_vec) <- prevalent_pop_map$ind_cluster_id

# 6. Create the full vector of new labels for every cell, in the correct order
# We use the 'ind_cluster_id' from the metadata to look up the new name.
new_labels_for_cells <- rename_vec[AllHB_indep$ind_cluster_id]

# 7. Create a dataframe to add as metadata. This is the safest way.
# The row names MUST be the cell barcodes to ensure correct matching.
new_metadata_df <- data.frame(
  donor_cluster_pop_label = new_labels_for_cells,
  row.names = colnames(AllHB_indep) # Use cell names from the object
)

# 8. Use AddMetaData to safely add the new column to the Seurat object
AllHB_indep <- AddMetaData(
  object = AllHB_indep,
  metadata = new_metadata_df
)

# 9. Set the new, correct labels as the active identity
Idents(AllHB_indep) <- "donor_cluster_pop_label"

cat("\n--- Verification ---\n")
cat("Clusters have been renamed on a per-donor basis.\n")
cat("A sample of the new identity levels:\n")
# This should now print the actual labels like "HB6_0_Naive", etc.
print(head(levels(AllHB_indep)))

# 10. Generate the corrected DimPlot using the new labels
cat("\n--- Generating Corrected DimPlot ---\n")

plot_independent_clusters_renamed <- DimPlot(
  object = AllHB_indep,
  reduction = "umap",
  split.by = "orig.ident",
  label = TRUE,
  repel = TRUE
  # No group.by needed since we set the Idents() correctly
)
###############
# Print the final, corrected plot
print(plot_independent_clusters_renamed)

plot_independent_clusters_renamed <- DimPlot(
  object = AllHB_indep,
  reduction = "umap",
  split.by = "orig.ident",
  label = TRUE,
  repel = TRUE
  # No group.by needed since we set the Idents() correctly
) + theme(legend.position = "none") # Add this line to remove the legend

# Print the final, corrected plot
print(plot_independent_clusters_renamed)
```

he script will print the new identity levels and the first few rows of your metadata. You should see a new column named `donor_cluster_pop_label` with names like `HB6_5_DN`, `HB34_1_Naive`, etc.

Step 1: Set the Active Identity

```{r}
# Set the active identity to the 'Population' column from your metadata
Idents(AllHB_indep) <- "donor_cluster_pop_label"

# You can check the levels to confirm it worked
levels(AllHB_indep)
```

### ONLY SHOWING THE POPULATION OF ORIGIN

rename indents:

```{r}
# {r simplify_cluster_idents}

# --- 1. Get the current, long cluster names ---
old_cluster_names <- levels(AllHB_indep)

# --- 2. Create the new, simplified names ---

# Step 2a: Extract the base name (e.g., "Classical_Memory") from each long name
# This regular expression removes the "DONOR_NUMBER_" prefix
base_names <- sub("^[^_]+_[^_]+_", "", old_cluster_names)

# Step 2b: Automatically number any duplicates to make them unique
# (e.g., the second "DN" becomes "DN2")
new_cluster_names <- make.unique(base_names, sep = "")

# --- 3. Create the mapping for renaming ---
# This creates a named vector where: name = old name, value = new name
rename_map <- new_cluster_names
names(rename_map) <- old_cluster_names

# --- 4. Apply the renaming to the Seurat object ---
AllHB_indep <- RenameIdents(AllHB_indep, rename_map)

# --- 5. Verify the results ---
cat("Cluster identities have been renamed.\n")
cat("A sample of the new identity levels:\n")
print(head(levels(AllHB_indep), 20))
```

now

```{r}
# {r manual_ggplot_for_final_plot_USING_IDENTS}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(ggplot2)
library(ggrepel) # For non-overlapping text labels

# --- 1. Create a Master Data Frame for Plotting ---
cat("--- Preparing data frame for plotting ---\n")

# Get UMAP coordinates
umap_coords <- as.data.frame(Embeddings(AllHB_indep, reduction = "umap"))
colnames(umap_coords) <- c("umap_1", "umap_2")

# Create the plotting data frame directly, adding the active Idents as a new column.
plotting_df <- data.frame(
  umap_1 = umap_coords$umap_1,
  umap_2 = umap_coords$umap_2,
  orig.ident = AllHB_indep$orig.ident,
  Population = AllHB_indep$Population,
  ident_label = Idents(AllHB_indep) # Get active idents and add as 'ident_label'
)


# --- 2. Calculate Centroid Positions for Text Labels ---
cat("--- Calculating positions for text labels ---\n")

# Group by the new 'ident_label' column to find the center of each cluster
label_positions <- plotting_df %>%
  group_by(ident_label, orig.ident) %>% # <-- CHANGED from concise_label
  summarise(
    umap_1_median = median(umap_1),
    umap_2_median = median(umap_2),
    .groups = 'drop'
  )


# --- 3. Generate the Final Plot with ggplot2 ---
cat("--- Generating final plot using ggplot2 ---\n")

final_manual_plot <- ggplot() +
  # Layer 1: Draw all the points, colored by the original Population
  geom_point(data = plotting_df, aes(x = umap_1, y = umap_2, color = Population), size = 0.5, alpha = 0.8) +
  
  # Layer 2: Add the text labels using the 'ident_label' column
  geom_text_repel(data = label_positions, aes(x = umap_1_median, y = umap_2_median, label = ident_label), # <-- CHANGED from concise_label
                  size = 3.5, fontface = 'bold', box.padding = 0.5,
                  max.overlaps = Inf) +
                  
  # Layer 3: Split the plot into panels for each donor
  facet_wrap(~orig.ident) +
  
  # Layer 4: Apply themes and clean up labels
  theme_bw() +
  labs(
    title = "UMAP of B-Cell Populations by Donor",
    x = "UMAP 1",
    y = "UMAP 2"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    strip.text = element_text(face = "bold", size = 12),
    legend.position = "none" # Legend is removed as per your request
  )

# Print the final plot
print(final_manual_plot)
```

Correct error

```{r}
# {r manual_ggplot_with_default_colors}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(ggplot2)
library(ggrepel)

# --- 1. Create a Master Data Frame for Plotting ---
cat("--- Preparing data frame for plotting ---\n")
umap_coords <- as.data.frame(Embeddings(AllHB_indep, reduction = "umap"))
colnames(umap_coords) <- c("umap_1", "umap_2")

# Create a data frame that includes the unique cluster ID and the simplified label
plotting_df <- data.frame(
  umap_1 = umap_coords$umap_1,
  umap_2 = umap_coords$umap_2,
  orig.ident = AllHB_indep$orig.ident,
  Population = AllHB_indep$Population,
  unique_ident = Idents(AllHB_indep), # The unique ID (e.g., DN1, DN2)
  simple_label = sub("\\d+$", "", Idents(AllHB_indep)) # The simplified label (e.g., DN, DN)
)

# --- 2. Calculate Centroid Positions for Text Labels ---
cat("--- Calculating positions for text labels ---\n")

label_positions <- plotting_df %>%
  group_by(unique_ident, orig.ident, simple_label) %>% # Keep all info
  summarise(
    umap_1_median = median(umap_1),
    umap_2_median = median(umap_2),
    .groups = 'drop'
  )

# --- 3. Generate the Final Plot with ggplot2 ---
cat("--- Generating final plot with default colors ---\n")

final_manual_plot <- ggplot() +
  # Points are colored by the broader 'Population' category
  geom_point(data = plotting_df, aes(x = umap_1, y = umap_2, color = Population), size = 0.5, alpha = 0.8) +
  
  # The text labels on the plot use the 'simple_label' column (e.g., "DN")
  geom_text_repel(data = label_positions, aes(x = umap_1_median, y = umap_2_median, label = simple_label),
                  size = 3.5, fontface = 'bold', color = "black",
                  max.overlaps = Inf) +
                  
  facet_wrap(~orig.ident) +
  theme_bw() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Population") +
  theme(
    strip.text = element_text(face = "bold", size = 12),
    panel.grid = element_blank(),
    legend.position = "right" # Restore the legend to see default colors
  )

# Print the final plot
print(final_manual_plot)
```

### Find Significant Markers for Independent Clusters

##### Script to Calculate Significant Gene IN clusters against a backdrop of all three donors

Reorder Marker Dataframe by Donor

```{r}
# {r count_significant_markers_and_split}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(tidyr)

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# --- 1. Find All Marker Genes for Each Independent Cluster ---

# Set the active identity to your independent clusters
Idents(Object) <- "donor_cluster_pop_label"

cat("\n--- Finding all marker genes for each cluster... ---\n")

# Run FindAllMarkers to find differentially expressed genes
all_markers <- FindAllMarkers(
  Object,
  assay = "RNA",
  only.pos = TRUE,
  min.pct = 0.25,
  logfc.threshold = 0.25,
  verbose = FALSE
)

cat("FindAllMarkers complete.\n")


# --- 2. Count Significant Markers ---

# This creates the initial two-column data frame
significant_marker_counts <- all_markers %>%
  filter(p_val_adj < 0.05) %>%
  group_by(cluster) %>%
  summarise(number_of_significant_genes = n(), .groups = 'drop')


# --- 3. Add Donor Information for Splitting ---

# We need to extract the donor ID from the cluster name.
# The 'separate' function creates a new 'Donor' column we can use for splitting.
table_with_donor_info <- significant_marker_counts %>%
  separate(
    col = cluster,
    into = c("Donor", "Cluster_Number", "Population"),
    sep = "_",
    remove = FALSE, # Keep the original 'cluster' column
    extra = "merge"
  )

# --- 4. Split the Main Table into a List of Dataframes ---

# The split() function is perfect for this. It will create a list where
# each item in the list is a dataframe containing the data for one donor.
list_of_donor_dfs <- split(table_with_donor_info, table_with_donor_info$Donor)


# --- 5. Print Each Donor's Dataframe Separately ---

cat("\n--- Displaying Gene Counts per Cluster, Split by Donor ---\n")

# Now we loop through the list we just created and print each table.
for (donor_id in names(list_of_donor_dfs)) {
  
  cat(paste0("\n--- Donor: ", donor_id, " ---\n"))
  
  # Select only the two columns you want for the final clean output
  final_donor_table <- list_of_donor_dfs[[donor_id]] %>%
    select(cluster, number_of_significant_genes)
    
  print(as.data.frame(final_donor_table))
}

cat("\n--- Task Complete ---\n")

# You can also access any individual dataframe later using its name, for example:
# hb6_counts <- list_of_donor_dfs[["HB6"]]

```

Reorder Marker Dataframe by Donor and population. The comparison is **between each individual, donor-specific cluster and all other cells in the dataset. T**he analysis is designed to answer a more specific question: **"What genes make this particular sub-population (e.g., `HB6_0_Naive`) unique compared to everything else, including other Naive clusters from other donors?"**

The goal is to find the highly specific genes that define each small, unique cluster, which is why this is a powerful way to dissect the heterogeneity you've been investigating

```{r}
# {r count_significant_markers_sorted_and_split}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(tidyr)

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# --- 1. Find All Marker Genes for Each Independent Cluster ---

# Set the active identity to your independent clusters
Idents(Object) <- "donor_cluster_pop_label"

cat("\n--- Finding all marker genes for each cluster... ---\n")

# Run FindAllMarkers to find differentially expressed genes
all_markers <- FindAllMarkers(
  Object,
  assay = "RNA",
  only.pos = TRUE,
  min.pct = 0.25,
  logfc.threshold = 0.25,
  verbose = FALSE
)

cat("FindAllMarkers complete.\n")


# --- 2. Count Significant Markers ---

# This creates the initial two-column data frame
significant_marker_counts <- all_markers %>%
  filter(p_val_adj < 0.05) %>%
  group_by(cluster) %>%
  summarise(number_of_significant_genes = n(), .groups = 'drop')


# --- 3. Add Donor & Population Info and Reorder the Table ---

# Define the desired order for the cell populations
population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# This pipe now does two things:
# 1. Extracts the Donor and Population info from the cluster name.
# 2. Reorders the entire table based on Donor, and then by your specified population order.
sorted_table <- significant_marker_counts %>%
  separate(
    col = cluster,
    into = c("Donor", "Cluster_Number", "Population"),
    sep = "_",
    remove = FALSE, # Keep the original 'cluster' column
    extra = "merge"
  ) %>%
  # Convert the Population column to a factor with your custom order
  mutate(Population = factor(Population, levels = population_order)) %>%
  # Arrange the table first by Donor, then by the custom Population order
  arrange(Donor, Population)


# --- 4. Split the Sorted Table into a List of Dataframes ---

# The split() function will now operate on the correctly sorted table
list_of_donor_dfs <- split(sorted_table, sorted_table$Donor)


# --- 5. Print Each Donor's (Now Sorted) Dataframe Separately ---

cat("\n--- Displaying Gene Counts per Cluster, Sorted by Population and Split by Donor ---\n")

# The loop remains the same, but the data it prints is now correctly ordered.
for (donor_id in names(list_of_donor_dfs)) {
  
  cat(paste0("\n--- Donor: ", donor_id, " ---\n"))
  
  # Select only the two columns you want for the final clean output
  final_donor_table <- list_of_donor_dfs[[donor_id]] %>%
    select(cluster, number_of_significant_genes)
    
  print(as.data.frame(final_donor_table), row.names = FALSE)
}

cat("\n--- Task Complete ---\n")
```

In a graph:

```{r}
# {r count_significant_markers_and_graph} 

# --- Ensure necessary libraries are loaded ---
library(Seurat) 
library(dplyr) 
library(tidyr) 
library(ggplot2) # Added for plotting

# --- Set the object to analyze ---
Object <- AllHB_indep 
name_object <- "AllHB_indep" 
cat("Seurat object is:", name_object, "\n") 

# --- 1. Find All Marker Genes for Each Independent Cluster --- 

# Set the active identity to your independent clusters 
Idents(Object) <- "donor_cluster_pop_label" 

cat("\n--- Finding all marker genes for each cluster... ---\n") 

# Run FindAllMarkers to find differentially expressed genes 
all_markers <- FindAllMarkers( 
  Object, 
  assay = "RNA", 
  only.pos = TRUE, 
  min.pct = 0.25, 
  logfc.threshold = 0.25, 
  verbose = FALSE 
) 

cat("FindAllMarkers complete.\n") 


# --- 2. Count Significant Markers --- 

# This creates the initial two-column data frame 
significant_marker_counts <- all_markers %>% 
  filter(p_val_adj < 0.05) %>% 
  group_by(cluster) %>% 
  summarise(number_of_significant_genes = n(), .groups = 'drop') 


# --- 3. Add Donor & Population Info and Reorder the Table --- 

# Define the desired order for the cell populations 
population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN") 

# This pipe now does two things: 
# 1. Extracts the Donor and Population info from the cluster name. 
# 2. Creates a 'Population' factor with your specified order, which ggplot will respect.
sorted_table <- significant_marker_counts %>% 
  separate( 
    col = cluster, 
    into = c("Donor", "Cluster_Number", "Population"), 
    sep = "_", 
    remove = FALSE, # Keep the original 'cluster' column 
    extra = "merge" 
  ) %>% 
  # Convert the Population column to a factor with your custom order 
  mutate(Population = factor(Population, levels = population_order)) %>% 
  # Arrange the table first by Donor, then by the custom Population order 
  arrange(Donor, Population) 


# --- (The original section 4 & 5 to print tables can be kept or removed) ---
# For clarity, we will proceed directly to graphing from the 'sorted_table'


# --- NEW SECTION: 4. Graph the Results ---

cat("\n--- Generating plot of significant marker counts by population ---\n")

marker_plot <- ggplot(
  data = sorted_table, 
  # X-axis is the population, Y-axis is the gene count
  aes(x = Population, y = number_of_significant_genes)
) +
  
  # Add a boxplot layer to show the distribution (median, quartiles)
  geom_boxplot(
    width = 0.5,
    outlier.shape = NA, # Hide default outliers since we will plot all points
    fill = "lightgray",
    alpha = 0.5
  ) +
  
  # Add jittered points to show each individual cluster's gene count.
  # Points are colored by Donor to see if any donor stands out.
  geom_jitter(
    aes(color = Donor),
    width = 0.25, # Controls the amount of horizontal spread
    size = 2.5,   # Point size
    alpha = 0.8   # Point transparency
  ) +
  
  # Add plot labels and title
  labs(
    title = "Nº Significant Markers in cluster associated B-Cell Populations",
    subtitle = "Data aggregated across all donors and clusters",
    x = "B-Cell Population",
    y = "Nº Significant Genes ",
    color = "Donor" # Legend title for the colors
  ) +
  
  # Apply a clean, professional theme
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 15)),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 11, face = "bold"),
    axis.text.y = element_text(size = 11),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "top"
  )

# Print the plot to the viewer
print(marker_plot)

# --- Task Complete ---
cat("\n--- Task Complete ---\n")
```

THIS IS finding markers for clusters against a backdrop of all three donor. This graph reveals the transcriptional complexity of different B-cell populations by showing the number of unique genes that define each cluster. A higher number of significant genes indicates a more distinct and complex transcriptional state.Example, Naive B-cells are in a quiescent state, waiting for activation. Their cellular identity is stable and uniform, requiring relatively few unique genes to distinguish them from other cells. This low heterogeneity serves as a baseline for comparison.

**You are comparing Phenotypes !!**

-   t demonstrates that these traditionally defined populations are not single, uniform entities. Instead, they are composed of multiple, distinct subpopulations with vastly different transcriptional programs.

    -   A memory cluster with few marker genes may represent a deeply resting, "true" memory state.

    -   A memory cluster with hundreds of marker genes likely represents a more activated, specialized, or recently stimulated subpopulation.

-   Your observation is correct: the **DN (Double Negative) clusters are indeed very heterogeneous**.

### Script to Calculate Significant Genes for Each Donor Separately

I can use

```{r}
# {r rename_and_find_markers_per_donor_FIXED}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(tidyr)

# --- 1. Create a list of your donor-specific Seurat objects ---
list_of_donor_objects <- list(
  "HB6" = Only_HB6,
  "HB34" = Only_HB34,
  "HB78" = Only_HB78
)

# --- 2. Loop Through Each Donor Object to Perform the Analysis ---

cat("\n--- Processing Each Donor Separately ---\n")

for (donor_id in names(list_of_donor_objects)) {
  
  # Get the current Seurat object from the list
  current_donor_object <- list_of_donor_objects[[donor_id]]
  
  cat(paste0("\n--- Step A: Renaming clusters for Donor: ", donor_id, " ---\n"))
  
  # --- ROBUST RENAMING BLOCK ---
  
  # 1. Create a mapping table linking cluster number to prevalent population
  prevalent_pop_map <- current_donor_object@meta.data %>%
    group_by(seurat_clusters) %>%
    count(Population, name = "count") %>%
    top_n(1, count) %>%
    slice(1) %>%
    ungroup() %>%
    # Create the new, informative label in the mapping table
    mutate(donor_cluster_pop_label = paste(donor_id, seurat_clusters, Population, sep = "_")) %>%
    # Keep only the essential columns for the join
    select(seurat_clusters, donor_cluster_pop_label)

  # 2. Use a left_join to safely merge the new labels into the metadata
  # This preserves the cell barcodes (rownames)
  meta_data_new <- current_donor_object@meta.data %>%
    tibble::rownames_to_column("cell_barcode") %>%
    left_join(prevalent_pop_map, by = "seurat_clusters") %>%
    tibble::column_to_rownames("cell_barcode")

  # 3. Add the new metadata column to the Seurat object
  current_donor_object <- AddMetaData(current_donor_object, 
                                      metadata = meta_data_new$donor_cluster_pop_label, 
                                      col.name = "donor_cluster_pop_label")

  # 4. Set the new, informative labels as the active identity
  Idents(current_donor_object) <- "donor_cluster_pop_label"
  
  cat("Clusters renamed successfully.\n")
  
  # --- End of renaming block ---
  
  
  cat(paste0("\n--- Step B: Finding markers for Donor: ", donor_id, " ---\n"))

  # Run FindAllMarkers on the current donor object
  all_markers <- FindAllMarkers(
    current_donor_object,
    assay = "RNA",
    only.pos = TRUE,
    min.pct = 0.25,
    logfc.threshold = 0.25,
    verbose = FALSE
  )
  
  # Count the significant markers for each newly-named cluster
  significant_marker_counts <- all_markers %>%
    filter(p_val_adj < 0.05) %>%
    group_by(cluster) %>%
    summarise(number_of_significant_genes = n(), .groups = 'drop')
  
  # This block ensures all clusters are present in the final table
  all_clusters_df <- data.frame(cluster = levels(current_donor_object))
  final_counts <- all_clusters_df %>%
    left_join(significant_marker_counts, by = "cluster") %>%
    mutate(number_of_significant_genes = replace_na(number_of_significant_genes, 0))
    
  # Print the final table for the current donor
  cat("Counts of significant genes per cluster (vs. other cells from same donor):\n")
  print(as.data.frame(final_counts), row.names = FALSE)
  
} # End of the for loop

cat("\n--- All donors processed. ---\n")
```

### Fig5. poster

In graph

```{r}
# {r calculate_markers_and_generate_boxplot}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(ggplot2) # For plotting

# --- 1. Create a list of your donor-specific Seurat objects ---
list_of_donor_objects <- list(
  "HB6" = Only_HB6,
  "HB34" = Only_HB34,
  "HB78" = Only_HB78
)

# --- 2. Loop Through Each Donor Object to Find Markers ---

# Create an empty list to store the results from each donor
all_donor_results <- list()

cat("\n--- Processing Each Donor Separately ---\n")

for (donor_id in names(list_of_donor_objects)) {
  
  current_donor_object <- list_of_donor_objects[[donor_id]]
  cat(paste0("\n--- Processing Donor: ", donor_id, " ---\n"))
  
  # Set identities to the numerical clusters for this step
  Idents(current_donor_object) <- "seurat_clusters"
  
  # Run FindAllMarkers on the current donor object
  all_markers <- FindAllMarkers(
    current_donor_object,
    assay = "RNA",
    only.pos = TRUE,
    min.pct = 0.25,
    logfc.threshold = 0.25,
    verbose = FALSE
  )
  
  # Count the significant markers for each cluster
  significant_marker_counts <- all_markers %>%
    filter(p_val_adj < 0.05) %>%
    group_by(cluster) %>%
    summarise(number_of_significant_genes = n(), .groups = 'drop')
  
  # --- Add donor and population info to the results ---
  
  # Get the mapping of cluster number to prevalent population
  prevalent_pop_map <- current_donor_object@meta.data %>%
    group_by(seurat_clusters) %>%
    count(Population, name = "count") %>%
    top_n(1, count) %>%
    slice(1) %>%
    ungroup() %>%
    select(seurat_clusters, Population)

  # Join the counts with the population info
  donor_results <- prevalent_pop_map %>%
    left_join(significant_marker_counts, by = c("seurat_clusters" = "cluster")) %>%
    mutate(
      number_of_significant_genes = replace_na(number_of_significant_genes, 0),
      Donor = donor_id # Add a column for the donor ID
    )
  
  # Store the results for this donor in our list
  all_donor_results[[donor_id]] <- donor_results
  
} # End of the for loop

# --- 3. Combine Results and Create the Boxplot ---

# Combine the results from the three donors into a single data frame
final_summary_table <- bind_rows(all_donor_results)

# Ensure the Population column is a factor with the desired order for the plot
population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
final_summary_table$Population <- factor(final_summary_table$Population, levels = population_order)

cat("\n--- Generating Final Summary Boxplot ---\n")

# Use ggplot2 to create the boxplot
summary_boxplot <- ggplot(final_summary_table, aes(x = Population, y = number_of_significant_genes)) +
  # Add the boxplots
  geom_boxplot(outlier.shape = NA) + # Hides outlier points so geom_jitter can show them
  # Add the individual data points, colored by donor
  geom_jitter(aes(color = Donor), width = 0.2, size = 3, alpha = 0.8) +
  # Apply a clean theme and labels
  theme_bw() +
  labs(
    title = "Nº Significant Markers in Cluster-Associated B-Cell Populations",
    subtitle = "Data aggregated across all donors and clusters",
    x = "B-Cell Population",
    y = "Nº Significant Genes"
  ) +
  # Customize the text appearance
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )

# Print the final plot
print(summary_boxplot)
```

R Script to Find Novel Drivers of Heterogeneity

### Quantification Ig/TCR assocaited Gene Subgroups per Cluster

systematically check for the presence of specific gene families (Ig constant, V(D)J, etc.) within each of `donor_cluster_pop_label` . This can be done with a script that loops through each population in your `AllHB_indep` object, gets the list of all genes expressed in that population, and then uses your predefined lists and regular expressions to find matches.

Genes:

```{r}
# {r count_significant_markers_by_category_and_split_ALL_CLUSTERS}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(tidyr)

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# --- 1. Define the Gene Groups to Count ---
cat("\n--- Defining IG/TCR gene groups for counting ---\n")
ig_constant_genes_list <- c(
  "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
  "IGHG1", "IGHG2", "IGHG3", "IGHG4",
  "IGKC",
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
  "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"


# --- 2. Find All Marker Genes for Each Independent Cluster ---
Idents(Object) <- "donor_cluster_pop_label"
cat("\n--- Finding all marker genes for each cluster... ---\n")
all_markers <- FindAllMarkers(
  Object,
  assay = "RNA",
  only.pos = TRUE,
  min.pct = 0.25,
  logfc.threshold = 0.25,
  verbose = FALSE
)
cat("FindAllMarkers complete.\n")


# --- 3. THE NEW LOGIC TO INCLUDE ALL CLUSTERS ---

# Step A: Get a definitive list of ALL cluster names that exist in the Seurat object.
all_clusters_df <- data.frame(cluster = levels(Object))

# Step B: Calculate the counts for clusters that DO have significant IG/TCR genes.
# This part of the logic is the same as before.
category_counts <- all_markers %>%
  filter(p_val_adj < 0.05) %>%
  mutate(category = case_when(
    gene %in% ig_constant_genes_set ~ "Constant_Ig",
    grepl(ig_vdj_regex, gene)        ~ "Variable_Ig", # this VDJ
    grepl(igll_regex, gene)          ~ "Atypical_Ig", # this IGLL
    grepl(tcr_regex, gene)           ~ "TCR_gene",
    TRUE                             ~ "Other"
  )) %>%
  filter(category != "Other") %>%
  group_by(cluster, category) %>%
  summarise(count = n(), .groups = "drop") %>%
  pivot_wider(
    names_from = category,
    values_from = count,
    values_fill = 0
  )

# Step C: Use a left_join to merge the counts back to the complete list of all clusters.
# This is the crucial step that ensures no clusters are lost.
full_counts_table <- all_clusters_df %>%
  left_join(category_counts, by = "cluster")

# Step D: The join creates NAs for clusters with no genes. Replace these NAs with 0.
final_counts <- full_counts_table %>%
  mutate(across(where(is.numeric), ~replace_na(., 0)))


# --- 4. Add Donor & Population Info and Reorder the Table ---
population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

sorted_table <- final_counts %>%
  separate(
    col = cluster,
    into = c("Donor", "Cluster_Number", "Population"),
    sep = "_",
    remove = FALSE,
    extra = "merge"
  ) %>%
  mutate(Population = factor(Population, levels = population_order)) %>%
  arrange(Donor, Population)


# --- 5. Split the Sorted Table and Print Each Donor's Result ---
list_of_donor_dfs <- split(sorted_table, sorted_table$Donor)

cat("\n--- Displaying Counts of Significant IG/TCR Genes by Category (All Clusters Included) ---\n")

for (donor_id in names(list_of_donor_dfs)) {
  
  cat(paste0("\n--- Donor: ", donor_id, " ---\n"))
  
  # Define the columns you want in the final output
  final_output_cols <- c("cluster", "Constant_Ig", "Variable_Ig", "Atypical_Ig", "TCR_gene")
  
  # Select only the desired columns for the final clean output
  final_donor_table <- list_of_donor_dfs[[donor_id]] %>%
    select(any_of(final_output_cols))
    
  print(as.data.frame(final_donor_table), row.names = FALSE)
}

cat("\n--- Task Complete ---\n")
```

IN a graph:

```{r}
# {r count_and_graph_gene_categories_ALL_CLUSTERS}

# --- Ensure necessary libraries are loaded ---
library(Seurat)
library(dplyr)
library(tidyr)
library(ggplot2) # Added for plotting

# --- Set the object to analyze ---
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# --- 1. Define the Gene Groups to Count ---
cat("\n--- Defining IG/TCR gene groups for counting ---\n")
ig_constant_genes_list <- c(
  "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
  "IGHG1", "IGHG2", "IGHG3", "IGHG4",
  "IGKC",
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
  "AC233755.1"
)
ig_constant_genes_set <- as.character(unique(ig_constant_genes_list))
ig_vdj_regex <- "^IG[HKL][VDJ]"
igll_regex <- "^IGLL"
tcr_regex <- "^TR[ABGD][CV]"


# --- 2. Find All Marker Genes for Each Independent Cluster ---
Idents(Object) <- "donor_cluster_pop_label"
cat("\n--- Finding all marker genes for each cluster... ---\n")
all_markers <- FindAllMarkers(
  Object,
  assay = "RNA",
  only.pos = TRUE,
  min.pct = 0.25,
  logfc.threshold = 0.25,
  verbose = FALSE
)
cat("FindAllMarkers complete.\n")


# --- 3. LOGIC TO INCLUDE ALL CLUSTERS ---
all_clusters_df <- data.frame(cluster = levels(Object))
category_counts <- all_markers %>%
  filter(p_val_adj < 0.05) %>%
  mutate(category = case_when(
    gene %in% ig_constant_genes_set ~ "Constant_Ig",
    grepl(ig_vdj_regex, gene)       ~ "Variable_Ig",
    grepl(igll_regex, gene)         ~ "Atypical_Ig",
    grepl(tcr_regex, gene)          ~ "TCR_gene",
    TRUE                            ~ "Other"
  )) %>%
  filter(category != "Other") %>%
  group_by(cluster, category) %>%
  summarise(count = n(), .groups = "drop") %>%
  pivot_wider(
    names_from = category,
    values_from = count,
    values_fill = 0
  )
full_counts_table <- all_clusters_df %>%
  left_join(category_counts, by = "cluster")
final_counts <- full_counts_table %>%
  mutate(across(where(is.numeric), ~replace_na(., 0)))


# --- 4. Add Donor & Population Info ---
population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
sorted_table <- final_counts %>%
  separate(
    col = cluster,
    into = c("Donor", "Cluster_Number", "Population"),
    sep = "_",
    remove = FALSE,
    extra = "merge"
  ) %>%
  mutate(Population = factor(Population, levels = population_order))


# --- (Original printing loop is omitted for brevity before the plot) ---


# --- NEW SECTION: 5. Prepare Data and Generate Graph ---

cat("\n--- Reshaping data and generating plot... ---\n")

# Step A: Reshape the data from 'wide' to 'long' format, which is required for ggplot
plotting_data_long <- sorted_table %>%
  pivot_longer(
    cols = any_of(c("Constant_Ig", "Variable_Ig", "Atypical_Ig", "TCR_gene")),
    names_to = "gene_category",
    values_to = "count"
  ) %>%
  # Filter out categories with zero counts to avoid cluttering the plot
  filter(count > 0)

# Step B: Create an ordering for clusters within each facet. We'll order them
# by the total number of significant IG/TCR genes (descending).
cluster_order <- sorted_table %>%
  # Calculate total IG/TCR genes for each cluster
  mutate(total_genes = rowSums(across(any_of(c("Constant_Ig", "Variable_Ig", "Atypical_Ig", "TCR_gene"))))) %>%
  # Arrange by Population, then by the total count
  arrange(Population, desc(total_genes)) %>%
  # Pull out the cluster names in the new desired order
  pull(cluster)

# Step C: Apply the new cluster order to our plotting data
plotting_data_long$cluster <- factor(plotting_data_long$cluster, levels = cluster_order)

# Step D: Create simplified labels for the x-axis (e.g., "HB6_1" instead of "HB6_1_Naive")
# This prevents redundant information since the population is in the facet title.
simplified_labels <- sub("_[^_]+$", "", levels(plotting_data_long$cluster))
names(simplified_labels) <- levels(plotting_data_long$cluster)


# Step E: Build the plot
composition_plot <- ggplot(
    plotting_data_long,
    aes(x = cluster, y = count, fill = gene_category)
  ) +
  
  # Create the stacked bars
  geom_col() +
  
  # Create separate panels for each B-cell population
  # `scales = "free_x"` makes each panel's width proportional to its number of clusters
  facet_wrap(~ Population, scales = "free_x", ncol = 3) +
  
  # Use a color-blind friendly palette
  scale_fill_brewer(palette = "Set2") +
  
  # Add titles and labels
  labs(
    title = "Composition of Significant IG/TCR Marker Genes by Cluster",
    subtitle = "Clusters are grouped by B-cell population and ordered by total IG/TCR marker count",
    x = "Cluster",
    y = "Number of Significant Genes",
    fill = "Gene Category"
  ) +

  # Use the simplified labels for the x-axis
  scale_x_discrete(labels = simplified_labels) +
  
  # Apply a clean theme and improve text readability
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 11, hjust = 0.5, margin = margin(b = 15)),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 9),
    axis.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 12), # Facet titles
    legend.position = "top"
  )

# Print the plot
print(composition_plot)

cat("\n--- Task Complete ---\n")
```

## Expression of B Cell Markers and Ig Isotypes

gene expression patterns in your `Seurat`object match the expected canonical markers

#### Short list of genes (sroter + Ig Constant)

##### DEI\_ IG_constant_genes (HB6/34/78)

```{r}
# {r generate_dotplot_for_independent_clusters}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(tidyr)
library(ggplot2)

# This script creates a Dot Plot to visualize marker expression across
# the independently-run clusters defined by 'donor_cluster_pop_label'.

# --- 1. Define Seurat Object and Gene List ---

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# Define the list of genes to plot, including key markers and Ig isotypes
genes_to_plot <- c(
  "CD19", "MS4A1", "CD27", # B cell markers
  "IGHD", "IGHM",          # Naive/Transitional markers
  "IGHG1", "IGHG2", "IGHG3", "IGHG4", # IgG subclasses
  "IGHA1", "IGHA2",         # IgA subclasses
  "IGHE",                  # IgE
  "IGKC",                  # Kappa light chain
   "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",  # Lambda light chains
  "AC233755.1"
)

# To avoid errors, check which of these genes are actually present in the RNA assay
genes_to_plot <- intersect(genes_to_plot, rownames(GetAssay(Object, assay = "RNA")))

cat("Will plot the following found genes:\n")
print(genes_to_plot)

# --- 2. Prepare the Seurat Object for Plotting ---

# A. Ensure the active identity is set to our donor-specific clusters
Idents(Object) <- "donor_cluster_pop_label"

# B. Create an ordered factor for the identities to control the plot layout
# First, get the current levels
current_levels <- levels(Object)
# Create a data frame for easier sorting
level_df <- data.frame(Cluster = current_levels) %>%
  separate(
    Cluster,
    into = c("Donor", "Cluster_Num", "Population"),
    sep = "_",
    remove = FALSE,
    extra = "merge"
  )

# Define the custom population order
population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")

# Sort the levels by Donor, then by the custom Population order
level_df <- level_df %>%
  mutate(Population = factor(Population, levels = population_order)) %>%
  arrange(Donor, Population)

# Get the sorted cluster names to use as the final factor levels
sorted_levels <- level_df$Cluster

# Reorder the identity levels in the Seurat object
Object@active.ident <- factor(Object@active.ident, levels = sorted_levels)


# --- 3. Create the Dot Plot ---

cat("\nGenerating Dot Plot...\n")

# Create the plot using the defined genes and reordered cluster identities
marker_dot_plot <- DotPlot(
  Object,
  features = genes_to_plot,
  assay = "RNA" # Use the non-integrated data for expression
) +
  # Add a custom color gradient for aesthetics
  scale_colour_gradient2(low = "#4575B4", mid = "white", high = "#D73027") +
  labs(
    title = paste0("Expression of B Cell Markers in: ", name_object),
    subtitle = "Across Independently-run Clusters (Ordered by Donor and Population)"
  ) +
  # Rotate x-axis labels for better readability and adjust theme
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, face = "italic"),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

print(marker_dot_plot)

cat("\n--- Dot Plot generation complete. ---\n")

```

##### DEI\_ IG_constant_genes (HB6 &34 &78)

```{r}
# {r generate_dotplot_for_independent_clusters_split_by_donor}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(tidyr)
library(ggplot2)

# This script creates a separate Dot Plot for each donor to visualize marker expression.

# --- 1. Define Seurat Object and Gene List ---

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# Define the list of genes to plot
genes_to_plot <- c(
  "CD19", "MS4A1", "CD27", # B cell markers
  "IGHD", "IGHM",          # Naive/Transitional markers
  "IGHG1", "IGHG2", "IGHG3", "IGHG4", # IgG subclasses
  "IGHA1", "IGHA2",         # IgA subclasses
  "IGHE",                  # IgE
  "IGKC",                  # Kappa light chain
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7", # Lambda light chains
  "AC233755.1"
)

# Check which of these genes are actually present in the object
genes_to_plot <- intersect(genes_to_plot, rownames(GetAssay(Object, assay = "RNA")))
cat("Will plot the following found genes:\n")
print(genes_to_plot)

# --- 2. THE NEW LOOPING LOGIC ---

# Define the donors you want to create plots for
donors_to_plot <- c("HB6", "HB34", "HB78")

# Loop through each donor ID
for (donor_id in donors_to_plot) {
  
  cat(paste0("\n--- Generating Dot Plot for Donor: ", donor_id, " ---\n"))
  
  # A. Create a temporary Seurat object containing only the cells for the current donor
  donor_subset_obj <- subset(Object, subset = orig.ident == donor_id)
  
  # B. Prepare the subset object by ordering its clusters correctly
  # (This ensures the y-axis of each plot is sorted by population type)
  
  # Get the cluster names for THIS donor only
  donor_levels <- levels(droplevels(donor_subset_obj@active.ident))
  
  level_df <- data.frame(Cluster = donor_levels) %>%
    separate(
      Cluster,
      into = c("Donor", "Cluster_Num", "Population"),
      sep = "_",
      remove = FALSE,
      extra = "merge"
    )
  
  population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")
  
  level_df <- level_df %>%
    mutate(Population = factor(Population, levels = population_order)) %>%
    arrange(Population) # We only need to arrange by Population now
  
  sorted_donor_levels <- level_df$Cluster
  
  # Reorder the identity levels in the donor-specific subset object
  donor_subset_obj@active.ident <- factor(donor_subset_obj@active.ident, levels = sorted_donor_levels)
  
  # C. Create the Dot Plot for the current donor
  marker_dot_plot <- DotPlot(
    donor_subset_obj,
    features = genes_to_plot,
    assay = "RNA"
  ) +
    scale_colour_gradient2(low = "#4575B4", mid = "white", high = "#D73027") +
    labs(
      title = paste0("Expression of B Cell Markers for Donor: ", donor_id), # Updated title
      subtitle = paste("Source Object:", name_object)
    ) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, face = "italic"),
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5)
    )
  
  # Print the plot for the current donor
  print(marker_dot_plot)
  
} # End of the for loop

cat("\n--- All plots generated. ---\n")
```

Splitted according to Population

```{r}
# {r generate_dotplot_for_independent_clusters}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)
library(tidyr)
library(ggplot2)

# This script creates a Dot Plot to visualize marker expression across
# the independently-run clusters defined by 'donor_cluster_pop_label'.
# It will generate a separate plot for each major population type.

# --- 1. Define Seurat Object and Gene List ---

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# Define the list of genes to plot, including key markers and Ig isotypes
genes_to_plot <- c(
  "CD19", "MS4A1", "CD27", # B cell markers
  "IGHD", "IGHM",          # Naive/Transitional markers
  "IGHG1", "IGHG2", "IGHG3", "IGHG4", # IgG subclasses
  "IGHA1", "IGHA2",         # IgA subclasses
  "IGHE",                  # IgE
  "IGKC",                  # Kappa light chain
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",  # Lambda light chains
  "AC233755.1"
)

# To avoid errors, check which of these genes are actually present in the RNA assay
genes_to_plot <- intersect(genes_to_plot, rownames(GetAssay(Object, assay = "RNA")))

cat("Will plot the following found genes:\n")
print(genes_to_plot)

# --- 2. Prepare the Seurat Object for Plotting ---

# A. Ensure the active identity is set to our donor-specific clusters
Idents(Object) <- "donor_cluster_pop_label"

# B. Define the population types to create separate plots for
population_order <- c("Transitional", "Naive", "IgM_Memory", "Classical_Memory", "DN")


# --- 3. Create a Separate Dot Plot for Each Population Type ---

cat("\nGenerating a separate Dot Plot for each population type...\n")

# Loop through each population type
for (pop_type in population_order) {
    
    cat(paste("\n--- Generating plot for Population:", pop_type, "---\n"))

    # Find all cluster names that match the current population type
    # We use grep to find the pattern "_PopulationName" at the end of the string ($)
    clusters_for_this_pop <- grep(paste0("_", pop_type, "$"), levels(Object), value = TRUE)
    
    # Check if any clusters were found for this population type. If not, skip to the next.
    if (length(clusters_for_this_pop) == 0) {
        cat("No clusters found for this population type. Skipping.\n")
        next # Moves to the next population type in the loop
    }

    # Subset the main object to get only the relevant clusters
    pop_subset_obj <- subset(Object, idents = clusters_for_this_pop)

    # For a clean plot, we can reorder the identities in the subset object
    # A simple alphabetical sort is sufficient to group donors together
    sorted_levels_subset <- sort(levels(droplevels(pop_subset_obj@active.ident)))
    pop_subset_obj@active.ident <- factor(pop_subset_obj@active.ident, levels = sorted_levels_subset)

    # Create the Dot Plot for this specific subset
    marker_dot_plot <- DotPlot(
      pop_subset_obj,
      features = genes_to_plot,
      assay = "RNA" # Use the non-integrated data for expression
    ) +
      # Add a custom color gradient for aesthetics
      scale_colour_gradient2(low = "#4575B4", mid = "white", high = "#D73027") +
      labs(
        title = paste("Expression for", pop_type, "Clusters"),
        subtitle = paste("Object:", name_object),
        x = "Genes", # Label for x-axis
        y = "Cluster"  # Label for y-axis
      ) +
      # Rotate x-axis labels for better readability and adjust theme
      theme(
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, face = "italic"),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)
      )
      
    # Print the plot for the current population
    print(marker_dot_plot)
}

cat("\n--- Dot Plot generation complete. ---\n")

```

#### Feature Plot for IG/TCR genes on Independent Clusters by Donor

F**eature Plot** to see the expression of kappa and lambda genes overlaid on your UMAP, and you want it split into the three donor panels

```{r generate_light_chain_featureplots}

# Ensure necessary libraries are loaded
library(Seurat)
library(ggplot2)

# This script generates a single grid of FeaturePlots for Kappa and Lambda
# light chain genes, with genes as columns and donors as rows.

# --- 1. Define Seurat Object and Gene List ---

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# Define the list of Kappa and Lambda light chain genes to plot
light_chain_genes <- c(
  "IGKC", 
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7"
)

# Filter for genes that are actually present in the object to avoid errors
genes_to_plot_final <- intersect(light_chain_genes, rownames(GetAssay(Object, assay = "RNA")))

cat("\n--- Generating grid plot for the following light chain genes: ---\n")
print(genes_to_plot_final)


# --- 2. Create the Split Feature Plot Grid ---

# We call FeaturePlot once with the full list of genes.
# 'split.by' will create the rows for each donor.
light_chain_grid_plot <- FeaturePlot(
  Object,
  features = genes_to_plot_final,
  split.by = "orig.ident", # Creates rows for each donor
  order = TRUE,
  pt.size = 0.2,
  combine = TRUE # Ensures themes are applied to all sub-plots
) & # Use the '&' to apply the following styles to ALL panels in the grid
  scale_colour_gradientn(colors = c("lightgrey", "#4575B4", "#313695")) &
  theme(
    plot.title = element_text(size = 12, face = "bold"),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
  )

# Print the final combined plot
print(light_chain_grid_plot)

cat("\n--- All plots generated. ---\n")


```

on the other way:

```{r}
# {r generate_light_chain_featureplots_manual_ggplot}

# Ensure necessary libraries are loaded
library(Seurat)
library(ggplot2)
library(dplyr)
library(tidyr)

# This script manually extracts data from the Seurat object and uses ggplot2
# to create a feature plot grid. This provides maximum control over the final plot.

# --- 1. Define Seurat Object and Gene List ---

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# Define the list of Kappa and Lambda light chain genes to plot
light_chain_genes <- c(
  "IGKC", 
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7"
)

# Filter for genes that are actually present in the object
genes_to_plot_final <- intersect(light_chain_genes, rownames(GetAssay(Object, assay = "RNA")))

if(length(genes_to_plot_final) == 0){
    stop("None of the specified light chain genes were found in the object.")
}

cat("\n--- Generating manual grid plot for: ---\n")
print(genes_to_plot_final)


# --- 2. Extract Data for Plotting ---

# Get UMAP coordinates for all cells
umap_coords <- as.data.frame(Embeddings(Object, reduction = "umap"))
colnames(umap_coords) <- c("UMAP_1", "UMAP_2")

# Get expression data for our specific genes
# We transpose it to have cells as rows and genes as columns
expression_data <- as.data.frame(t(GetAssayData(Object, assay = "RNA", slot = "data")[genes_to_plot_final, ]))

# Get the donor information
donor_data <- Object@meta.data %>% select(orig.ident)

# Combine everything into a single data frame
plotting_df <- cbind(umap_coords, expression_data, donor_data)


# --- 3. Restructure Data for ggplot2 ---

# Convert the data from "wide" format to "long" format, which is required by ggplot2
plotting_df_long <- plotting_df %>%
  pivot_longer(
    cols = all_of(genes_to_plot_final), # The columns to pivot are our genes
    names_to = "Gene",                 # The new column for gene names
    values_to = "Expression"           # The new column for expression values
  )

# Order the genes as they were in the original list for a consistent plot
plotting_df_long$Gene <- factor(plotting_df_long$Gene, levels = genes_to_plot_final)


# --- 4. Create the Plot with ggplot2 ---

cat("\n--- Building plot with ggplot2... ---\n")

manual_grid_plot <- ggplot(plotting_df_long, aes(x = UMAP_1, y = UMAP_2, color = Expression)) +
  # Add the points, setting size and shape
  geom_point(size = 0.1, shape = 16) +
  # Use facet_grid to create the grid: genes on the y-axis, donors on the x-axis
  facet_grid(Gene ~ orig.ident) +
  # Apply the color scale
  scale_colour_gradientn(colors = c("lightgrey", "#4575B4", "#313695")) +
  # Use a clean theme
  theme_minimal() +
  # Apply final theme customizations for a clean look
  theme(
    # Set donor names (top) to be horizontal
    strip.text.x = element_text(angle = 0, face = "bold", hjust = 0.5),
    # Set gene names (right) to be horizontal
    strip.text.y = element_text(angle = 0, face = "bold", hjust = 0.5),
    # Remove all axis labels and ticks
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank() # Remove grid lines
  )

# Print the final plot
print(manual_grid_plot)

cat("\n--- Plot generation complete. ---\n")

```

Grouped on group of genes:

```{r generate_module_score_featureplot}

# This script calculates an aggregated expression score (module score) for
# four different gene groups and visualizes these scores on a UMAP grid,
# with donors as rows and gene groups as columns.

# --- 1. Define Seurat Object and Gene Groups ---

# Set the object to analyze
Object <- AllHB_indep
name_object <- "AllHB_indep"
cat("Seurat object is:", name_object, "\n")

# Get all gene names from the RNA assay for matching
all_genes <- rownames(GetAssay(Object, assay = "RNA"))

# --- Group 1: Ig Constant Genes ---
ig_constant_genes_list <- c(
  "IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2",
  "IGHG1", "IGHG2", "IGHG3", "IGHG4", "IGKC",
  "IGLC1", "IGLC2", "IGLC3", "IGLC4", "IGLC5", "IGLC6", "IGLC7",
  "AC233755.1"
)
# Filter for genes actually present in the object
group1_constant <- list(intersect(ig_constant_genes_list, all_genes))

# --- Group 2: Ig V(D)J Genes ---
group2_vdj <- list(grep("^IG[HKL][VDJ]", all_genes, value = TRUE))

# --- Group 3: IGLL Genes ---
group3_igll <- list(grep("^IGLL", all_genes, value = TRUE))

# --- Group 4: TCR Genes ---
group4_tcr <- list(grep("^TR[ABGD][CV]", all_genes, value = TRUE))

cat("\n--- Found Genes per Group ---\n")
cat("Constant Ig Genes:", length(group1_constant[[1]]), "\n")
cat("V(D)J Ig Genes:", length(group2_vdj[[1]]), "\n")
cat("IGLL Genes:", length(group3_igll[[1]]), "\n")
cat("TCR Genes:", length(group4_tcr[[1]]), "\n")


# --- 2. Calculate Module Score for Each Group ---

cat("\n--- Calculating Module Scores ---\n")
# We use AddModuleScore to calculate an aggregated score for each gene list.
# We run it for each group and give each score a unique name.

Object <- AddModuleScore(
  object = Object,
  features = group1_constant,
  name = "Constant_Ig_Score", # This will create a column named Constant_Ig_Score1
  assay = "RNA"
)

Object <- AddModuleScore(
  object = Object,
  features = group2_vdj,
  name = "VDJ_Ig_Score", # Creates VDJ_Ig_Score1
  assay = "RNA"
)

Object <- AddModuleScore(
  object = Object,
  features = group3_igll,
  name = "IGLL_Score", # Creates IGLL_Score1
  assay = "RNA"
)

Object <- AddModuleScore(
  object = Object,
  features = group4_tcr,
  name = "TCR_Score", # Creates TCR_Score1
  assay = "RNA"
)

cat("Module scores added to object metadata.\n")
# You can see the new columns by running: head(Object@meta.data)


# --- 3. Create the Split Feature Plot Grid ---

# We now plot these new metadata columns just like we would plot genes.
# FeaturePlot will automatically create a grid when given multiple features.
features_to_plot <- c("Constant_Ig_Score1", "VDJ_Ig_Score1", "IGLL_Score1", "TCR_Score1")

module_score_plot <- FeaturePlot(
  object = Object,
  features = features_to_plot,
  split.by = "orig.ident", # This creates the rows for each donor
  reduction = "umap",
  order = TRUE,           # Plot high-scoring cells on top
  pt.size = 0.2,
  combine = TRUE          # This ensures ggplot2 themes are applied to all panels
) & # The '&' allows us to apply the theme to all sub-plots
  scale_colour_gradientn(colors = c("lightgrey", "#4575B4", "#313695")) &
  theme(
      plot.title = element_text(size = 12, face = "bold"),
      axis.title.x = element_blank(), # Remove x-axis title
      axis.title.y = element_blank(), # Remove y-axis title
      axis.text.x = element_blank(),  # Remove x-axis labels
      axis.text.y = element_blank(),  # Remove y-axis labels
      axis.ticks = element_blank()    # Remove axis ticks
  )


# Print the final plot grid
print(module_score_plot)

cat("\n--- Plot generation complete. ---\n")


```

reference:

```{r}
# Use the newly named object as input for the plot
plot_independent_clusters <- DimPlot(AllHB_indep, # <- Renamed variable
                                     reduction = "umap", 
                                 group.by = "Population", 
                                     label = TRUE, 
                                     repel = TRUE)

print(plot_independent_clusters)

# Use the newly named object as input for the plot
plot_independent_clusters <- DimPlot(AllHB_indep, # <- Renamed variable
                                     reduction = "umap", 
                                     
                                     label = TRUE, 
                                     repel = TRUE)

print(plot_independent_clusters)
```

```{r}
# {r generate_dimplot_with_smaller_legend}

# Ensure necessary libraries are loaded
library(Seurat)
library(ggplot2)

# This script generates the main DimPlot for your independent clusters
# and then modifies the plot to have a smaller legend.

# --- 1. Define Seurat Object and Generate the Plot ---

# Set the object to analyze
Object <- AllHB_indep

# Ensure the correct identities are active (from previous steps)
# This should be 'donor_cluster_pop_label'
Idents(Object) <- "donor_cluster_pop_label"

# Generate the main plot object, but don't print it yet.
# The 'repel = TRUE' argument moves labels to prevent them from overlapping.
plot_independent_clusters <- DimPlot(
  object = Object,
  reduction = "umap",
  label = TRUE,
  repel = TRUE
)

# --- 2. Modify the Legend ---

# Now we add a ggplot2 theme layer to the plot object we just created.
# This allows us to customize the appearance.
plot_with_small_legend <- plot_independent_clusters + 
  theme(
    # Control the font size of the legend text (the cluster names)
    legend.text = element_text(size = 6), # <-- You can change this number (e.g., 8, 5)
    
    # Optional: You can also make the colored dots in the legend smaller
    legend.key.size = unit(0.3, "cm") # Adjust the size of the legend keys
  )

# --- 3. Print the Final Plot ---

cat("--- Displaying DimPlot with smaller legend ---\n")

# Print the final, modified plot to the console
print(plot_with_small_legend)


```

gfh

### R Script for Pathway Analysis on Independent Clusters

Performing pathway analysis on your independent clusters is an excellent way to understand the specific biological function of each subpopulation you've identified.

```{r}
# # {r pathway_analysis_on_independent_clusters}
# 
# # --- 1. Load Necessary Libraries ---
# library(Seurat)
# library(dplyr)
# library(clusterProfiler)
# library(org.Hs.eg.db) # Human genome annotation database
# library(ggplot2)
# 
# # This script finds marker genes for each independent cluster and performs
# # Gene Ontology (GO) enrichment analysis on them.
# 
# # --- 2. Find Marker Genes for Each Independent Cluster ---
# # This assumes 'AllHB_indep' is your Seurat object with detailed cluster names set as Idents.
# 
# cat("--- Finding marker genes for each independent cluster ---\n")
# Idents(AllHB_indep) <- "donor_cluster_pop_label"
# all_cluster_markers <- FindAllMarkers(
#   AllHB_indep,
#   assay = "RNA",
#   only.pos = TRUE,
#   logfc.threshold = 0.25,
#   verbose = FALSE
# )
# 
# # Filter for only the statistically significant markers
# significant_cluster_markers <- all_cluster_markers %>%
#   filter(p_val_adj < 0.05)
# 
# 
# # --- 3. Prepare Gene Lists for Analysis ---
# cat("--- Preparing gene lists for pathway analysis ---\n")
# 
# # Convert gene symbols to Entrez Gene IDs
# gene_symbols <- unique(significant_cluster_markers$gene)
# entrez_ids <- bitr(
#   gene_symbols,
#   fromType = "SYMBOL",
#   toType = "ENTREZID",
#   OrgDb = "org.Hs.eg.db"
# )
# 
# # Join the Entrez IDs with our marker gene table
# markers_with_ids <- significant_cluster_markers %>%
#   left_join(entrez_ids, by = c("gene" = "SYMBOL")) %>%
#   filter(!is.na(ENTREZID))
# 
# # Create a named list of Entrez IDs, where each item in the list
# # is a vector of genes for one cluster. This is the required format for compareCluster.
# gene_list_for_comparison <- split(markers_with_ids$ENTREZID, markers_with_ids$cluster)
# 
# 
# # --- 4. Run and Visualize the Enrichment Analysis ---
# cat("--- Running compareCluster and generating plot ---\n")
# 
# # Use compareCluster to run enrichGO on all our cluster gene lists at once
# comparison_results <- compareCluster(
#   geneCluster = gene_list_for_comparison,
#   fun = "enrichGO",
#   OrgDb = "org.Hs.eg.db",
#   ont = "BP", # Analyze Biological Processes
#   pvalueCutoff = 0.05,
#   qvalueCutoff = 0.1
# )
# 
# # Create and print the dot plot, making text smaller for readability
# dotplot(comparison_results, showCategory = 15, title = "Enriched Biological Processes by Independent Cluster") +
#   theme(axis.text.y = element_text(size = 8))
```

he current plot is too crowded to be useful. Splitting the pathway analysis results into a separate plot for each donor is an excellent way to make it much more readable.

The best way to do this is to loop through each donor, filter the list of significant genes to include only the clusters from that donor, and then run the pathway analysis and plotting for each one separately.

Here is the amended R script to create three separate dot plots.

### Which genes are more involved in clustering

The genes at the top of this list are the ones that had the largest influence on the PCA and, consequently, on the clustering results. Instead of *`selection.method = "vst"`* We used the `selection.method = "mean.var.plot"` (which can be abbreviated to `"mvp"`) is a simpler, non-parametric method. It identifies variable genes by calculating their average expression and variance and selecting those with high variance relative to their expression level, without trying to fit a complex statistical model.

-   This approach is not sensitive to the "zero variance" issue and will run successfully on your `AllHB_indep` object, allowing the rest of your script to proceed without error.

    ```{r}
    # {r find_and_plot_variable_features_FIXED}

    # --- 1. Run FindVariableFeatures using a more robust selection method ---

    cat("--- Running FindVariableFeatures on AllHB_indep ---\n")

    # *** THE FIX: Switched from "vst" to "mean.var.plot" ***
    AllHB_indep <- FindVariableFeatures(AllHB_indep, selection.method = "mean.var.plot", nfeatures = 2000)

    cat("FindVariableFeatures complete.\n\n")


    # --- 2. Now, the rest of your code will work correctly ---

    # Get the full list of the most variable genes
    variable_genes <- VariableFeatures(AllHB_indep)

    # Print the top 20 most influential genes
    cat("Top 20 Most Variable Features:\n")
    print(head(variable_genes, 40))

    # Visualize the variable features on a plot
    variable_plot <- VariableFeaturePlot(AllHB_indep)
    LabelPoints(plot = variable_plot, points = head(variable_genes, 40), repel = TRUE)
    ```

**Interpretation:** The genes at the top of this list and the labeled outliers on the plot are the ones that had the most cell-to-cell variation and were therefore considered most important for the downstream analysis.

### AllHB. Analyze PCA Loadings

This method tells you which of the variable genes had the most weight in creating the principal components (PCs) that were used to build the clusters. Genes with high loading scores are the most influential drivers of the visual separation you see in the UMAP.

```{r}
# Print the top 10 genes with the highest positive and negative loadings
# for the first 5 PCs. Adjust 'dims' to match the PCs you used for clustering.
cat("\nTop Genes Contributing to Principal Components:\n")
print(AllHB[["pca"]], dims = 1:5, nfeatures = 10)

# Create a heatmap to visualize the genes driving the first PC
DimHeatmap(AllHB, dims = 1, cells = 500, balanced = TRUE)

# Visualize the top genes for the first two PCs
VizDimLoadings(AllHB, dims = 1:2, reduction = "pca")
```

### **R Code to Find Relevant Genes per Phenotype**

This script will perform the steps described above and give you a list of the most important clustering genes for each of your B-cell populations.

```{r}
# {r find_relevant_genes_per_phenotype}

# Ensure necessary libraries are loaded
library(Seurat)
library(dplyr)

# --- 1. Find the marker genes for each 'Population' ---
cat("--- Finding marker genes for each B-cell population ---\n")

# Set the active identity to the phenotype populations
Idents(AllHB) <- "Population"

# Find markers for every population compared to all other cells
population_markers <- FindAllMarkers(
  AllHB,
  assay = "RNA",
  only.pos = TRUE,
  logfc.threshold = 0.25,
  verbose = FALSE
)

# Filter for only the statistically significant markers
significant_markers <- population_markers %>%
  filter(p_val_adj < 0.05)


# --- 2. Get the genes that drove the clustering ---
# These are the highly variable features used for PCA
variable_features <- VariableFeatures(AllHB)


# --- 3. Find and Display the Overlap for Each Phenotype ---
cat("\n--- Most Relevant Clustering Genes per Phenotype ---\n")

# Get the list of unique phenotypes
phenotypes <- unique(significant_markers$cluster)

# Loop through each phenotype to find the overlapping genes
for (phenotype in phenotypes) {
  
  # Get the top markers for the current phenotype
  top_phenotype_markers <- significant_markers %>%
    filter(cluster == phenotype) %>%
    pull(gene) # pull() extracts the 'gene' column as a vector
  
  # Find the intersection between the phenotype markers and the variable features
  relevant_genes <- intersect(top_phenotype_markers, variable_features)
  
  # Print the results
  cat(paste0("\n--- Phenotype: ", phenotype, " ---\n"))
  cat("Top marker genes that were also used for clustering:\n")
  print(head(relevant_genes, 15)) # Print the top 15 relevant genes
  
}
```

The script will print a list for each phenotype (Transitional, Naive, etc.). The genes under each heading are the ones that are both **statistically significant markers for that population** AND were among the **most variable genes used to create the PCA and UMAP**.

Therefore, these are the genes most responsible for causing that specific phenotype to form its distinct clusters.

```{# {r}
# # {r create_table_of_relevant_genes}
# 
# # Ensure necessary libraries are loaded
# library(Seurat)
# library(dplyr)
# library(knitr) # For creating a nicely formatted table
# 
# # --- 1. Find the marker genes for each 'Population' ---
# cat("--- Finding marker genes for each B-cell population ---\n")
# Idents(AllHB) <- "Population"
# population_markers <- FindAllMarkers(
#   AllHB,
#   assay = "RNA",
#   only.pos = TRUE,
#   logfc.threshold = 0.25,
#   verbose = FALSE
# )
# significant_markers <- population_markers %>%
#   filter(p_val_adj < 0.05)
# 
# 
# # --- 2. Get the genes that drove the clustering ---
# variable_features <- VariableFeatures(AllHB)
# 
# 
# # --- 3. Create a Data Frame of the Overlapping Genes ---
# cat("\n--- Generating table of most relevant clustering genes per phenotype ---\n")
# 
# # Get the list of unique phenotypes
# phenotypes <- unique(significant_markers$cluster)
# 
# # Create an empty list to store a data frame for each phenotype
# list_of_dfs <- list()
# 
# # Loop through each phenotype to find the overlapping genes
# for (phenotype in phenotypes) {
#   
#   # Get the top markers for the current phenotype
#   top_phenotype_markers <- significant_markers %>%
#     filter(cluster == phenotype) %>%
#     pull(gene)
#   
#   # Find the intersection between the phenotype markers and the variable features
#   relevant_genes <- intersect(top_phenotype_markers, variable_features)
#   
#   # Create a data frame for the current phenotype and its relevant genes
#   # and add it to our list
#   if (length(relevant_genes) > 0) {
#     list_of_dfs[[phenotype]] <- data.frame(
#       Phenotype = phenotype,
#       Relevant_Gene = relevant_genes
#     )
#   }
# }
# 
# # Combine the list of data frames into one final table
# final_table <- bind_rows(list_of_dfs)
# 
# # --- 4. Display the Final Table ---
# # kable() creates a clean, publication-ready table
# knitr::kable(final_table, caption = "Most Relevant Genes for Clustering by Phenotype")
```

fds

```{# {r}
# # {r pathway_enrichment_analysis}
# 
# # --- 1. Load Necessary Libraries ---
# library(clusterProfiler)
# library(org.Hs.eg.db) # Human genome annotation database
# library(dplyr)
# library(ggplot2)
# 
# # This script assumes 'final_table' from the previous step exists.
# # final_table has two columns: 'Phenotype' and 'Relevant_Gene'
# 
# cat("--- Starting Pathway Enrichment Analysis for each phenotype ---\n")
# 
# 
# # --- 2. Prepare Gene Lists ---
# # We need to convert our gene symbols (e.g., "MS4A1") to Entrez Gene IDs,
# # which are required by clusterProfiler.
# 
# # Create a mapping of all unique genes in our table to Entrez IDs
# gene_symbols <- unique(final_table$Relevant_Gene)
# entrez_ids <- bitr(gene_symbols, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
# 
# # Join this back to our final_table to have both gene symbols and Entrez IDs
# final_table_with_ids <- final_table %>%
#   left_join(entrez_ids, by = c("Relevant_Gene" = "SYMBOL")) %>%
#   # Remove genes that could not be mapped to an Entrez ID
#   filter(!is.na(ENTREZID))
# 
# 
# # --- 3. Run Enrichment Analysis for Each Phenotype ---
# 
# # Get the list of unique phenotypes to loop through
# phenotypes <- unique(final_table_with_ids$Phenotype)
# 
# # Create an empty list to store the enrichment results for each phenotype
# enrichment_results_list <- list()
# 
# for (phenotype in phenotypes) {
#   
#   cat(paste0("\n--- Analyzing phenotype: ", phenotype, " ---\n"))
#   
#   # Get the list of Entrez IDs for the current phenotype
#   gene_list_entrez <- final_table_with_ids %>%
#     filter(Phenotype == phenotype) %>%
#     pull(ENTREZID)
#     
#   # Run Gene Ontology (GO) enrichment analysis for Biological Process (BP)
#   go_results <- enrichGO(
#     gene          = gene_list_entrez,
#     OrgDb         = org.Hs.eg.db,
#     keyType       = 'ENTREZID',
#     ont           = "BP", # Analyze Biological Processes. Use "MF" or "CC" for others.
#     pAdjustMethod = "BH",
#     qvalueCutoff  = 0.05,
#     pvalueCutoff  = 0.01
#   )
#   
#   if (!is.null(go_results) && nrow(go_results) > 0) {
#     # Store the results in our list
#     enrichment_results_list[[phenotype]] <- go_results
#     
#     # Print the top results for the current phenotype
#     cat("Top enriched GO Biological Process terms:\n")
#     print(head(as.data.frame(go_results)))
#     
#   } else {
#     cat("No significant enrichment found for this phenotype.\n")
#   }
# }
# 
# 
# # --- 4. Visualize the Results ---
# # A dot plot is a great way to compare the top pathways across all phenotypes.
# 
# cat("\n--- Generating summary dot plot of enriched pathways ---\n")
# 
# # The compareCluster function is perfect for this
# # It requires a named list of gene IDs
# gene_list_for_comparison <- split(final_table_with_ids$ENTREZID, final_table_with_ids$Phenotype)
# 
# comparison_results <- compareCluster(
#   geneCluster = gene_list_for_comparison,
#   fun = "enrichGO",
#   OrgDb = "org.Hs.eg.db",
#   ont = "BP",
#   pvalueCutoff = 0.05
# )
# 
# # Create and print the dot plot
# dotplot(comparison_results, showCategory = 10, title = "Top Enriched Biological Processes by Phenotype")
# 
# # {r readable_dot_plot}
# 
# # This script assumes 'comparison_results' from the previous step exists.
# 
# # --- Generate the Dot Plot with Modifications for Readability ---
# 
# # Create the initial dot plot object
# dot_plot_object <- dotplot(
#   comparison_results,
#   showCategory = 15,  #  <-- Tip 1: Show fewer categories (e.g., 15) to reduce clutter
#   title = "Top Enriched Biological Processes by Phenotype"
# )
# 
# # Now, add a theme layer to modify the plot
# readable_dot_plot <- dot_plot_object +
#   theme(
#     # *** THIS IS THE KEY MODIFICATION ***
#     # Decrease the font size of the y-axis text labels
#     axis.text.y = element_text(size = 5) #<-- Tip 2: Adjust size as needed (e.g., 8, 9, 10)
#   )
# 
# # Print the final, more readable plot
# print(readable_dot_plot)
```

### **How to Interpret the Output**

-   **Description:** This tells you the name of the biological pathway (e.g., "B cell activation," "lymphocyte differentiation").

-   **GeneRatio:** This shows the proportion of your genes that are found in that specific pathway.

-   **p.adjust / qvalue:** This is the most important value. It is the p-value adjusted for multiple testing. A low value (typically \< 0.05) indicates that the over-representation of your genes in that pathway is statistically significant and not just due to random chance.

This analysis will give you a table and a plot showing which biological processes are most significantly associated with the unique gene signatures of your different B-cell populations.

### SessionINFO:

```{r}
sessionInfo()
```
